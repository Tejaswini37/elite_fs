<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>unit-3</title><style>
    /* cspell:disable-file */
    /* webkit printing magic: print all background colors */
    html {
        -webkit-print-color-adjust: exact;
    }
    * {
        box-sizing: border-box;
        -webkit-print-color-adjust: exact;
    }
    
    html,
    body {
        margin: 0;
        padding: 0;
    }
    @media only screen {
        body {
            margin: 2em auto;
            max-width: 900px;
            color: rgb(55, 53, 47);
        }
    }
    
    body {
        line-height: 1.5;
        white-space: pre-wrap;
    }
    
    a,
    a.visited {
        color: inherit;
        text-decoration: underline;
    }
    
    .pdf-relative-link-path {
        font-size: 80%;
        color: #444;
    }
    
    h1,
    h2,
    h3 {
        letter-spacing: -0.01em;
        line-height: 1.2;
        font-weight: 600;
        margin-bottom: 0;
    }
    
    .page-title {
        font-size: 2.5rem;
        font-weight: 700;
        margin-top: 0;
        margin-bottom: 0.75em;
    }
    
    h1 {
        font-size: 1.875rem;
        margin-top: 1.875rem;
    }
    
    h2 {
        font-size: 1.5rem;
        margin-top: 1.5rem;
    }
    
    h3 {
        font-size: 1.25rem;
        margin-top: 1.25rem;
    }
    
    .source {
        border: 1px solid #ddd;
        border-radius: 3px;
        padding: 1.5em;
        word-break: break-all;
    }
    
    .callout {
        border-radius: 3px;
        padding: 1rem;
    }
    
    figure {
        margin: 1.25em 0;
        page-break-inside: avoid;
    }
    
    figcaption {
        opacity: 0.5;
        font-size: 85%;
        margin-top: 0.5em;
    }
    
    mark {
        background-color: transparent;
    }
    
    .indented {
        padding-left: 1.5em;
    }
    
    hr {
        background: transparent;
        display: block;
        width: 100%;
        height: 1px;
        visibility: visible;
        border: none;
        border-bottom: 1px solid rgba(55, 53, 47, 0.09);
    }
    
    img {
        max-width: 100%;
    }
    
    @media only print {
        img {
            max-height: 100vh;
            object-fit: contain;
        }
    }
    
    @page {
        margin: 1in;
    }
    
    .collection-content {
        font-size: 0.875rem;
    }
    
    .column-list {
        display: flex;
        justify-content: space-between;
    }
    
    .column {
        padding: 0 1em;
    }
    
    .column:first-child {
        padding-left: 0;
    }
    
    .column:last-child {
        padding-right: 0;
    }
    
    .table_of_contents-item {
        display: block;
        font-size: 0.875rem;
        line-height: 1.3;
        padding: 0.125rem;
    }
    
    .table_of_contents-indent-1 {
        margin-left: 1.5rem;
    }
    
    .table_of_contents-indent-2 {
        margin-left: 3rem;
    }
    
    .table_of_contents-indent-3 {
        margin-left: 4.5rem;
    }
    
    .table_of_contents-link {
        text-decoration: none;
        opacity: 0.7;
        border-bottom: 1px solid rgba(55, 53, 47, 0.18);
    }
    
    table,
    th,
    td {
        border: 1px solid rgba(55, 53, 47, 0.09);
        border-collapse: collapse;
    }
    
    table {
        border-left: none;
        border-right: none;
    }
    
    th,
    td {
        font-weight: normal;
        padding: 0.25em 0.5em;
        line-height: 1.5;
        min-height: 1.5em;
        text-align: left;
    }
    
    th {
        color: rgba(55, 53, 47, 0.6);
    }
    
    ol,
    ul {
        margin: 0;
        margin-block-start: 0.6em;
        margin-block-end: 0.6em;
    }
    
    li > ol:first-child,
    li > ul:first-child {
        margin-block-start: 0.6em;
    }
    
    ul > li {
        list-style: disc;
    }
    
    ul.to-do-list {
        padding-inline-start: 0;
    }
    
    ul.to-do-list > li {
        list-style: none;
    }
    
    .to-do-children-checked {
        text-decoration: line-through;
        opacity: 0.375;
    }
    
    ul.toggle > li {
        list-style: none;
    }
    
    ul {
        padding-inline-start: 1.7em;
    }
    
    ul > li {
        padding-left: 0.1em;
    }
    
    ol {
        padding-inline-start: 1.6em;
    }
    
    ol > li {
        padding-left: 0.2em;
    }
    
    .mono ol {
        padding-inline-start: 2em;
    }
    
    .mono ol > li {
        text-indent: -0.4em;
    }
    
    .toggle {
        padding-inline-start: 0em;
        list-style-type: none;
    }
    
    /* Indent toggle children */
    .toggle > li > details {
        padding-left: 1.7em;
    }
    
    .toggle > li > details > summary {
        margin-left: -1.1em;
    }
    
    .selected-value {
        display: inline-block;
        padding: 0 0.5em;
        background: rgba(206, 205, 202, 0.5);
        border-radius: 3px;
        margin-right: 0.5em;
        margin-top: 0.3em;
        margin-bottom: 0.3em;
        white-space: nowrap;
    }
    
    .collection-title {
        display: inline-block;
        margin-right: 1em;
    }
    
    .page-description {
        margin-bottom: 2em;
    }
    
    .simple-table {
        margin-top: 1em;
        font-size: 0.875rem;
        empty-cells: show;
    }
    .simple-table td {
        height: 29px;
        min-width: 120px;
    }
    
    .simple-table th {
        height: 29px;
        min-width: 120px;
    }
    
    .simple-table-header-color {
        background: rgb(247, 246, 243);
        color: black;
    }
    .simple-table-header {
        font-weight: 500;
    }
    
    time {
        opacity: 0.5;
    }
    
    .icon {
        display: inline-block;
        max-width: 1.2em;
        max-height: 1.2em;
        text-decoration: none;
        vertical-align: text-bottom;
        margin-right: 0.5em;
    }
    
    img.icon {
        border-radius: 3px;
    }
    
    .user-icon {
        width: 1.5em;
        height: 1.5em;
        border-radius: 100%;
        margin-right: 0.5rem;
    }
    
    .user-icon-inner {
        font-size: 0.8em;
    }
    
    .text-icon {
        border: 1px solid #000;
        text-align: center;
    }
    
    .page-cover-image {
        display: block;
        object-fit: cover;
        width: 100%;
        max-height: 30vh;
    }
    
    .page-header-icon {
        font-size: 3rem;
        margin-bottom: 1rem;
    }
    
    .page-header-icon-with-cover {
        margin-top: -0.72em;
        margin-left: 0.07em;
    }
    
    .page-header-icon img {
        border-radius: 3px;
    }
    
    .link-to-page {
        margin: 1em 0;
        padding: 0;
        border: none;
        font-weight: 500;
    }
    
    p > .user {
        opacity: 0.5;
    }
    
    td > .user,
    td > time {
        white-space: nowrap;
    }
    
    input[type="checkbox"] {
        transform: scale(1.5);
        margin-right: 0.6em;
        vertical-align: middle;
    }
    
    p {
        margin-top: 0.5em;
        margin-bottom: 0.5em;
    }
    
    .image {
        border: none;
        margin: 1.5em 0;
        padding: 0;
        border-radius: 0;
        text-align: center;
    }
    
    .code,
    code {
        background: rgba(135, 131, 120, 0.15);
        border-radius: 3px;
        padding: 0.2em 0.4em;
        border-radius: 3px;
        font-size: 85%;
        tab-size: 2;
    }
    
    code {
        color: #eb5757;
    }
    
    .code {
        padding: 1.5em 1em;
    }
    
    .code-wrap {
        white-space: pre-wrap;
        word-break: break-all;
    }
    
    .code > code {
        background: none;
        padding: 0;
        font-size: 100%;
        color: inherit;
    }
    
    blockquote {
        font-size: 1.25em;
        margin: 1em 0;
        padding-left: 1em;
        border-left: 3px solid rgb(55, 53, 47);
    }
    
    .bookmark {
        text-decoration: none;
        max-height: 8em;
        padding: 0;
        display: flex;
        width: 100%;
        align-items: stretch;
    }
    
    .bookmark-title {
        font-size: 0.85em;
        overflow: hidden;
        text-overflow: ellipsis;
        height: 1.75em;
        white-space: nowrap;
    }
    
    .bookmark-text {
        display: flex;
        flex-direction: column;
    }
    
    .bookmark-info {
        flex: 4 1 180px;
        padding: 12px 14px 14px;
        display: flex;
        flex-direction: column;
        justify-content: space-between;
    }
    
    .bookmark-image {
        width: 33%;
        flex: 1 1 180px;
        display: block;
        position: relative;
        object-fit: cover;
        border-radius: 1px;
    }
    
    .bookmark-description {
        color: rgba(55, 53, 47, 0.6);
        font-size: 0.75em;
        overflow: hidden;
        max-height: 4.5em;
        word-break: break-word;
    }
    
    .bookmark-href {
        font-size: 0.75em;
        margin-top: 0.25em;
    }
    
    .sans { font-family: ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI Variable Display", "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol"; }
    .code { font-family: "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace; }
    .serif { font-family: Lyon-Text, Georgia, ui-serif, serif; }
    .mono { font-family: iawriter-mono, Nitti, Menlo, Courier, monospace; }
    .pdf .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI Variable Display", "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK JP'; }
    .pdf:lang(zh-CN) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI Variable Display", "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC'; }
    .pdf:lang(zh-TW) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI Variable Display", "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK TC'; }
    .pdf:lang(ko-KR) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI Variable Display", "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK KR'; }
    .pdf .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
    .pdf:lang(zh-CN) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
    .pdf:lang(zh-TW) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
    .pdf:lang(ko-KR) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
    .pdf .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK JP'; }
    .pdf:lang(zh-CN) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK SC'; }
    .pdf:lang(zh-TW) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK TC'; }
    .pdf:lang(ko-KR) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK KR'; }
    .pdf .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
    .pdf:lang(zh-CN) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
    .pdf:lang(zh-TW) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
    .pdf:lang(ko-KR) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
    .highlight-default {
        color: rgba(55, 53, 47, 1);
    }
    .highlight-gray {
        color: rgba(120, 119, 116, 1);
        fill: rgba(120, 119, 116, 1);
    }
    .highlight-brown {
        color: rgba(159, 107, 83, 1);
        fill: rgba(159, 107, 83, 1);
    }
    .highlight-orange {
        color: rgba(217, 115, 13, 1);
        fill: rgba(217, 115, 13, 1);
    }
    .highlight-yellow {
        color: rgba(203, 145, 47, 1);
        fill: rgba(203, 145, 47, 1);
    }
    .highlight-teal {
        color: rgba(68, 131, 97, 1);
        fill: rgba(68, 131, 97, 1);
    }
    .highlight-blue {
        color: rgba(51, 126, 169, 1);
        fill: rgba(51, 126, 169, 1);
    }
    .highlight-purple {
        color: rgba(144, 101, 176, 1);
        fill: rgba(144, 101, 176, 1);
    }
    .highlight-pink {
        color: rgba(193, 76, 138, 1);
        fill: rgba(193, 76, 138, 1);
    }
    .highlight-red {
        color: rgba(212, 76, 71, 1);
        fill: rgba(212, 76, 71, 1);
    }
    .highlight-default_background {
        color: rgba(55, 53, 47, 1);
    }
    .highlight-gray_background {
        background: rgba(241, 241, 239, 1);
    }
    .highlight-brown_background {
        background: rgba(244, 238, 238, 1);
    }
    .highlight-orange_background {
        background: rgba(251, 236, 221, 1);
    }
    .highlight-yellow_background {
        background: rgba(251, 243, 219, 1);
    }
    .highlight-teal_background {
        background: rgba(237, 243, 236, 1);
    }
    .highlight-blue_background {
        background: rgba(231, 243, 248, 1);
    }
    .highlight-purple_background {
        background: rgba(244, 240, 247, 0.8);
    }
    .highlight-pink_background {
        background: rgba(249, 238, 243, 0.8);
    }
    .highlight-red_background {
        background: rgba(253, 235, 236, 1);
    }
    .block-color-default {
        color: inherit;
        fill: inherit;
    }
    .block-color-gray {
        color: rgba(120, 119, 116, 1);
        fill: rgba(120, 119, 116, 1);
    }
    .block-color-brown {
        color: rgba(159, 107, 83, 1);
        fill: rgba(159, 107, 83, 1);
    }
    .block-color-orange {
        color: rgba(217, 115, 13, 1);
        fill: rgba(217, 115, 13, 1);
    }
    .block-color-yellow {
        color: rgba(203, 145, 47, 1);
        fill: rgba(203, 145, 47, 1);
    }
    .block-color-teal {
        color: rgba(68, 131, 97, 1);
        fill: rgba(68, 131, 97, 1);
    }
    .block-color-blue {
        color: rgba(51, 126, 169, 1);
        fill: rgba(51, 126, 169, 1);
    }
    .block-color-purple {
        color: rgba(144, 101, 176, 1);
        fill: rgba(144, 101, 176, 1);
    }
    .block-color-pink {
        color: rgba(193, 76, 138, 1);
        fill: rgba(193, 76, 138, 1);
    }
    .block-color-red {
        color: rgba(212, 76, 71, 1);
        fill: rgba(212, 76, 71, 1);
    }
    .block-color-default_background {
        color: inherit;
        fill: inherit;
    }
    .block-color-gray_background {
        background: rgba(241, 241, 239, 1);
    }
    .block-color-brown_background {
        background: rgba(244, 238, 238, 1);
    }
    .block-color-orange_background {
        background: rgba(251, 236, 221, 1);
    }
    .block-color-yellow_background {
        background: rgba(251, 243, 219, 1);
    }
    .block-color-teal_background {
        background: rgba(237, 243, 236, 1);
    }
    .block-color-blue_background {
        background: rgba(231, 243, 248, 1);
    }
    .block-color-purple_background {
        background: rgba(244, 240, 247, 0.8);
    }
    .block-color-pink_background {
        background: rgba(249, 238, 243, 0.8);
    }
    .block-color-red_background {
        background: rgba(253, 235, 236, 1);
    }
    .select-value-color-uiBlue { background-color: rgba(35, 131, 226, .07); }
    .select-value-color-pink { background-color: rgba(245, 224, 233, 1); }
    .select-value-color-purple { background-color: rgba(232, 222, 238, 1); }
    .select-value-color-green { background-color: rgba(219, 237, 219, 1); }
    .select-value-color-gray { background-color: rgba(227, 226, 224, 1); }
    .select-value-color-transparentGray { background-color: rgba(227, 226, 224, 0); }
    .select-value-color-translucentGray { background-color: rgba(0, 0, 0, 0.06); }
    .select-value-color-orange { background-color: rgba(250, 222, 201, 1); }
    .select-value-color-brown { background-color: rgba(238, 224, 218, 1); }
    .select-value-color-red { background-color: rgba(255, 226, 221, 1); }
    .select-value-color-yellow { background-color: rgba(253, 236, 200, 1); }
    .select-value-color-blue { background-color: rgba(211, 229, 239, 1); }
    .select-value-color-pageGlass { background-color: undefined; }
    .select-value-color-washGlass { background-color: undefined; }
    
    .checkbox {
        display: inline-flex;
        vertical-align: text-bottom;
        width: 16;
        height: 16;
        background-size: 16px;
        margin-left: 2px;
        margin-right: 5px;
    }
    
    .checkbox-on {
        background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22%2358A9D7%22%2F%3E%0A%3Cpath%20d%3D%22M6.71429%2012.2852L14%204.9995L12.7143%203.71436L6.71429%209.71378L3.28571%206.2831L2%207.57092L6.71429%2012.2852Z%22%20fill%3D%22white%22%2F%3E%0A%3C%2Fsvg%3E");
    }
    
    .checkbox-off {
        background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20x%3D%220.75%22%20y%3D%220.75%22%20width%3D%2214.5%22%20height%3D%2214.5%22%20fill%3D%22white%22%20stroke%3D%22%2336352F%22%20stroke-width%3D%221.5%22%2F%3E%0A%3C%2Fsvg%3E");
    }
        
    </style></head><body><article id="15758fd8-d211-8093-91b2-d15958297273" class="page sans"><header><h1 class="page-title">unit-3</h1><p class="page-description"></p></header><div class="page-body"><p id="15758fd8-d211-8045-9160-d1eac4bb703d" class="">
    </p><p id="15758fd8-d211-8021-8fb5-f0b52f04d53a" class="">
    </p><p id="15758fd8-d211-80f8-8510-d911d13593d7" class="">
    </p><h2 id="15758fd8-d211-80a8-8cbe-d402bcbce241" class="">Work Schedule</h2><p id="15758fd8-d211-80b9-b253-dc597c818e8b" class="">You are working in a factory, and your task is to schedule the works (jobs) to maximize profit.<br/>Each job has a unique ID, a deadline (in units of time), and a profit that is earned by completing the job within its deadline.<br/>There are a limited number of time slots available, and each slot can only hold one job.<br/></p><p id="15758fd8-d211-8048-ab8f-fa63ce02c489" class="">Your task is to Schedule the jobs such that the maximum profit is obtained without missing any job&#x27;s deadline.</p><p id="15758fd8-d211-809d-b8cf-c70800bfb550" class="">Your goal is to find the maximum profit that can be earned by sequencing the jobs optimally.</p><p id="15758fd8-d211-806f-8447-f2737b759670" class="">Remember, only one task can be executed at a time, and you cannot exceed the available slots.</p><h2 id="15758fd8-d211-80fb-94ee-c52eba3de322" class="">Input Format:</h2><p id="15758fd8-d211-8071-bdf0-c03801e3e005" class="">Line-1: An integer n representing the number of jobs.<br/>Line-2 to n: Each containing three space-separated integers:<br/>-Task ID: A unique identifier for each job.<br/>-Deadline: The latest time (in units) by which the job can be completed.<br/>-Profit: The profit earned from completing the job.<br/>Line n+1: An integer T representing the number of time slots available (in units of time).<br/></p><h2 id="15758fd8-d211-8005-8608-db8681efdb35" class="">Output Format:</h2><p id="15758fd8-d211-80a2-8711-e1369faa8da7" class="">Line-1: An integer representing the total profit earned by scheduling the jobs.</p><h2 id="15758fd8-d211-8010-96e1-d1ebc1f2a1d6" class="">Example 1:</h2><p id="15758fd8-d211-80ee-aefa-fa644d58822a" class="">10<br/>1 9 15<br/>2 2 2<br/>3 5 18<br/>4 7 1<br/>5 4 25<br/>6 2 20<br/>7 5 8<br/>8 7 10<br/>9 4 12<br/>10 3 5<br/>15<br/>output =109<br/></p><h2 id="15758fd8-d211-80a8-bb5f-ec9ce75f7db9" class="">Explanation :</h2><p id="15758fd8-d211-8014-9e31-ea1c3f7dcda1" class="">If we choose tasks 1, 3, 4, 5, 6, 7, 8, and 9, we can achieve a maximum profit of 109.<br/>Note that task 2 and task 10 are left out, because they cannot be done in their associated deadlines.<br/></p><h2 id="15758fd8-d211-808f-8ba0-d1c86d77e8dc" class="">Example 2:</h2><p id="15758fd8-d211-8061-baac-c906bb355144" class="">input = 10<br/>1 9 15<br/>2 2 2<br/>3 5 18<br/>4 7 1<br/>5 4 25<br/>6 2 20<br/>7 5 8<br/>8 7 10<br/>9 4 12<br/>10 3 5<br/>5<br/>output =90<br/></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="15758fd8-d211-8096-83ba-dbbfdb835821" class="code"><code class="language-Java">import java.util.*;
    
    class Solution{
        
        static int getLatestSlot(int slot[],int curr)
        {
            int time=slot.length;
            for(int i=curr;i&gt;=0;i--)
            {
                if(slot[i]==-1)
                {
                    return i;
                }
            }
            return -1;
        }
        static int scheduleJobs(int[][] arr, int time){
            int n=arr.length;
            Arrays.sort(arr,(a,b)-&gt;b[2]-a[2]);
            int maxProf=0;
            int slots[] = new int[time];
            Arrays.fill(slots,-1);
            for(int i=0;i&lt;n;i++){
                int cur = Math.min(arr[i][1]-1,time-1);
                int lat = getLatestSlot(slots,cur);
                if(lat!=-1)
                {
                    // System.out.println(arr[i][0]+&quot; occupied &quot;+arr[i][1]);
                    slots[lat]=cur;
                    maxProf+=arr[i][2];
                }
            }
            
            return maxProf;
        }
        public static void main(String args[])
        {
            Scanner sc = new Scanner(System.in);
            int n=sc.nextInt();
            int[][] arr = new int[n][3];
            for(int i=0;i&lt;n;i++)
            {
                for(int j=0;j&lt;3;j++)
                {
                    arr[i][j]=sc.nextInt();
                }
            }
            
            int time = sc.nextInt();
            System.out.println(scheduleJobs(arr,time));
        }
    }</code></pre><h2 id="15758fd8-d211-80f2-b6e6-e660b86fa82f" class="">BFS</h2><p id="15758fd8-d211-801f-91a2-decdd68577c2" class="">You are given an undirected graph represented by vertices and edges.<br/>Your task is to implement Breadth-First Search (BFS) traversal from a given starting vertex.<br/>The graph is represented using an adjacency list, and you need to traverse the graph starting from a specified vertex.<br/></p><h2 id="15758fd8-d211-8078-96b4-fb39289270f5" class="">Input Format:</h2><p id="15758fd8-d211-806e-beb8-cf626ab54a35" class="">Line-1: An integer V, the number of vertices.<br/>Line-2: An integer E, the number of edges.<br/>Line-3 to E: The next E lines contain two integers source and destination, representing an edge between the two vertices in the graph.<br/>Line-E+1: The starting vertex S from which BFS traversal should begin.<br/></p><h2 id="15758fd8-d211-803e-b35d-d6fc6ae60248" class="">Output Format:</h2><p id="15758fd8-d211-80d1-983e-d9943e97b64e" class="">Line-1: Print the vertices visited in BFS order starting from the given vertex S.</p><h2 id="15758fd8-d211-803c-8344-d4734d6336e1" class="">Constraints:</h2><ul id="15758fd8-d211-8031-93c8-f727e71e2186" class="bulleted-list"><li style="list-style-type:disc">1 ≤ V ≤ 100<br/>*0 ≤ E ≤ V * (V - 1)<br/>*0 ≤ source, destination, S &lt; V<br/></li></ul><h2 id="15758fd8-d211-80f8-8f51-e2ff266979b5" class="">Sample Input-1:</h2><p id="15758fd8-d211-80ad-98b0-ced22571fec9" class="">5<br/>8<br/>0 1<br/>0 4<br/>1 0<br/>1 2<br/>1 3<br/>1 4<br/>2 3<br/>3 4<br/>0<br/></p><h2 id="15758fd8-d211-8044-8773-ffffe371390d" class="">Sample Output-1:</h2><p id="15758fd8-d211-809c-90cb-fcb85166d197" class="">0 1 4 2 3</p><h2 id="15758fd8-d211-8026-9039-ebac4b06fb85" class="">Sample Input-1:</h2><p id="15758fd8-d211-8072-a020-c7041a682b26" class="">4<br/>4<br/>0 1<br/>0 2<br/>1 3<br/>2 3<br/>2<br/></p><h2 id="15758fd8-d211-80e9-abf3-e0bc5e4c8ccd" class="">Sample Output-2:</h2><p id="15758fd8-d211-8050-a330-ee4dfeb114ad" class="">2 0 3 1</p><p id="15758fd8-d211-80cf-a02d-d324201334b6" class="">
    </p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="15758fd8-d211-80e0-b6d2-c67b336bab43" class="code"><code class="language-Plain Text" style="white-space:pre-wrap;word-break:break-all">import java.util.*;
    
    class Solution {
    static List&lt;Integer&gt; BFS(List&lt;List&lt;Integer&gt;&gt; adjList, List&lt;Integer&gt; res, int source) {
        Queue&lt;Integer&gt; q = new LinkedList&lt;&gt;();
        boolean[] vis = new boolean[adjList.size()];
        Arrays.fill(vis, false);
        q.offer(source);
        vis[source] = true;
    
        while (!q.isEmpty()) {
            int vert = q.poll();
            res.add(vert);
            List&lt;Integer&gt; adjN = adjList.get(vert);
            for (int x : adjN) {
                if (!vis[x]) {
                    vis[x] = true;
                    q.offer(x);
                }
            }
        }
        return res;
    }
    
    static void makeAdjList(int[][] graph, List&lt;List&lt;Integer&gt;&gt; adjList, int e) {
        for (int i = 0; i &lt; e; i++) {
            int u = graph[i][0];
            int v = graph[i][1];
            adjList.get(u).add(v);
            adjList.get(v).add(u);
        }
    }
    
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int v = sc.nextInt();
        int e = sc.nextInt();
        int graph[][] = new int[e][2];
    
        for (int i = 0; i &lt; e; i++) {
            for (int j = 0; j &lt; 2; j++) {
                graph[i][j] = sc.nextInt();
            }
        }
    
        int source = sc.nextInt();
    
        List&lt;List&lt;Integer&gt;&gt; adjList = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt; v; i++) adjList.add(new ArrayList&lt;&gt;());
    
        makeAdjList(graph, adjList, e);
    
        List&lt;Integer&gt; res = new ArrayList&lt;&gt;();
        BFS(adjList, res, source);
    
        for (int node : res) {
            System.out.print(node + &quot; &quot;);
        }
    }
    </code></pre><p id="15758fd8-d211-803d-aa6a-efd938c808cd" class="">}</p><h2 id="15758fd8-d211-8049-841b-dc8e163e566d" class="">DFS</h2><p id="15758fd8-d211-8069-8abf-ee9c383d985a" class="">You are given a directed graph represented by vertices and edges.<br/>Your task is to implement Depth-First Search (DFS) traversal from a given starting vertex.<br/>The graph is represented using an adjacency list, and you need to traverse the graph starting from a specified vertex using an iterative approach (using a stack).<br/></p><h2 id="15758fd8-d211-8002-8d63-f2e87ac60e00" class="">Input Format:</h2><p id="15758fd8-d211-80f9-9d97-dc7ec4c5ea42" class="">Line-1: An integer V, the number of vertices in the graph.<br/>Line-2: An integer E, the number of edges in the graph.<br/>Line3 to E: The next E lines each contain two integers source and destination, representing an edge from the source vertex to the destination vertex.<br/>Line-E+1: The starting vertex S from which DFS traversal should begin.<br/></p><h2 id="15758fd8-d211-8041-8118-d86087735717" class="">Output Format:</h2><p id="15758fd8-d211-80c4-b263-eb3ea55bea5a" class="">Line-1&quot; Print the vertices visited in DFS order starting from the given vertex S.</p><h2 id="15758fd8-d211-80c6-a1b1-d67305e10344" class="">Constraints:</h2><ul id="15758fd8-d211-800d-ba2e-fe5894d25d49" class="bulleted-list"><li style="list-style-type:disc">1 ≤ V ≤ 100<br/>*0 ≤ E ≤ V * (V - 1)<br/>*0 ≤ source, destination, S &lt; V<br/></li></ul><h2 id="15758fd8-d211-80fd-a76b-f7580f272f54" class="">Sample Input-1:</h2><p id="15758fd8-d211-8018-b992-f2e05c614ad5" class="">5<br/>8<br/>0 1<br/>0 4<br/>1 0<br/>1 2<br/>1 3<br/>1 4<br/>2 3<br/>3 4<br/>0<br/></p><h2 id="15758fd8-d211-807a-9093-c48b3e21f2b9" class="">Sample Output-1:</h2><p id="15758fd8-d211-8082-8f7e-cdd74908df08" class="">0 1 2 3 4</p><h2 id="15758fd8-d211-809b-9375-e879cbb5d33c" class="">Sample Input-2:</h2><p id="15758fd8-d211-80f1-b0f1-c03d076ae362" class="">7<br/>9<br/>0 1<br/>0 2<br/>1 3<br/>2 3<br/>3 4<br/>3 5<br/>4 6<br/>5 6<br/>6 1<br/>2<br/></p><h2 id="15758fd8-d211-8041-978b-e8a671e4eed1" class="">Sample Output-2:</h2><p id="15758fd8-d211-8071-959f-c38823c4a8cd" class="">2 3 4 6 1 5</p><p id="15758fd8-d211-80f9-8a4c-dda8415543d7" class="">
    </p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="15758fd8-d211-8030-a68f-e31993b10ef5" class="code"><code class="language-Plain Text" style="white-space:pre-wrap;word-break:break-all">import java.util.*;
    
    class Solution {
    static List&lt;Integer&gt; DFS(List&lt;List&lt;Integer&gt;&gt; adjList, List&lt;Integer&gt; res, int source) {
        Stack&lt;Integer&gt; s = new Stack&lt;&gt;();
        boolean[] vis = new boolean[adjList.size()];
        Arrays.fill(vis, false);
        s.push(source);
        vis[source] = true;
    
        while (!s.isEmpty()) {
            int vert = s.pop();
            res.add(vert);
            List&lt;Integer&gt; adjN = adjList.get(vert);
            Collections.reverse(adjN);
            for (int x : adjN) {
                if (!vis[x]) {
                    vis[x] = true;
                    s.push(x);
                }
            }
        }
        return res;
    }
    
    static void makeAdjList(int[][] graph, List&lt;List&lt;Integer&gt;&gt; adjList, int e) {
        for (int i = 0; i &lt; e; i++) {
            int u = graph[i][0];
            int v = graph[i][1];
            adjList.get(u).add(v);
            // adjList.get(v).add(u);
        }
    }
    
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int v = sc.nextInt();
        int e = sc.nextInt();
        int graph[][] = new int[e][2];
    
        for (int i = 0; i &lt; e; i++) {
            graph[i][0] = sc.nextInt();
            graph[i][1] = sc.nextInt();
        }
    
        int source = sc.nextInt();
    
        List&lt;List&lt;Integer&gt;&gt; adjList = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt; v; i++) adjList.add(new ArrayList&lt;&gt;());
    
        makeAdjList(graph, adjList, e);
    
        List&lt;Integer&gt; res = new ArrayList&lt;&gt;();
        DFS(adjList, res, source);
    
        for (int node : res) {
            System.out.print(node + &quot; &quot;);
        }
    }
    </code></pre><p id="15758fd8-d211-80a0-8b39-cc9c0028fa2b" class="">}</p><h2 id="15758fd8-d211-8091-a151-d3c135a58368" class=""><strong>Find_All_Lonely_Nodes</strong></h2><p id="15758fd8-d211-80be-b48a-e9879545fbdc" class="">In a joint family, every person assigned with an ID, an integer value.<br/>and the entire family is arranged in the from of tree.<br/></p><p id="15758fd8-d211-80e6-91e5-d833a3b1b353" class="">You will be given the family tree,<br/>your task is to find and print the person ID, who is only child to his/her parent.<br/>i.e, the person with no siblings. Print all such person ID&#x27;s in ascending order.<br/></p><p id="15758fd8-d211-80bd-bd47-e1060c236d98" class="">NOTE:<br/>- If only one person is there in the family, please consider him as a parent.<br/>- In the given tree, please consider &#x27;-1&#x27; as null.<br/></p><h2 id="15758fd8-d211-8037-b924-d6e46a7de338" class="">Input Format:</h2><p id="15758fd8-d211-80b6-99a1-d49e04698ab9" class="">Line-1: Space separated integers, person ID&#x27;s in the family.</p><h2 id="15758fd8-d211-80c1-a58e-fa171c8a9fc5" class="">Output Format:</h2><p id="15758fd8-d211-8064-b500-d9f657ae006a" class="">Line-1: Print the list of person IDs in ascending order.</p><h2 id="15758fd8-d211-80d9-8327-e145c27908bc" class="">Sample Input-1:</h2><p id="15758fd8-d211-80e6-8742-c41c3cfc4d13" class="">2 3 4 -1 5</p><h2 id="15758fd8-d211-809d-8401-c55f03699be0" class="">Sample Output-1:</h2><p id="15758fd8-d211-80c5-a8f9-d41fe7dd6919" class="">[5]</p><h2 id="15758fd8-d211-80d5-96b8-e8bf80de2bcf" class="">Sample Input-2:</h2><p id="15758fd8-d211-80ad-ab48-e9c9ca977f2c" class="">11 99 88 77 -1 -1 66 55 -1 -1 -1 -1 -1 -1 44</p><h2 id="15758fd8-d211-80f3-9bdb-f4d3a7a4c728" class="">Sample Output-2:</h2><p id="15758fd8-d211-806f-99d0-ec29f31d0dcb" class="">[44, 55, 66, 77]</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="15758fd8-d211-80c6-9738-edf74758a4f7" class="code"><code class="language-Java">import java.util.*;
    
    class BinaryTreeNode {
        public int data;
        public BinaryTreeNode left, right;
    
        public BinaryTreeNode(int data) {
            this.data = data;
            left = null;
            right = null;
        }
    }
    
    class Solution {
        // Method to get all lonely nodes in the tree using BFS
        // Return list of lonelyNodes
        public ArrayList&lt;Integer&gt; getLonelyNodes(BinaryTreeNode root) {
            //Write your code here
            ArrayList&lt;Integer&gt; l = new ArrayList&lt;&gt;();
            Queue&lt;BinaryTreeNode&gt; q =new LinkedList&lt;&gt;();
            q.offer(root);
            while(!q.isEmpty())
            {
                BinaryTreeNode node = q.poll();
                if(node.left!=null &amp;&amp; node.right==null)
                {
                    l.add(node.left.data);
                }
                if(node.right!=null &amp;&amp; node.left==null)
                {
                    l.add(node.right.data);
                }
                
                if(node.left!=null) q.offer(node.left);
                if(node.right!=null) q.offer(node.right);
            }
            return l;
        }
        
    }
    
    public class LonelyNodes {
        static BinaryTreeNode root;
    
        // Function to construct the tree based on input using level-order insertion
        BinaryTreeNode buildTreeFromInput(Integer[] arr) {
            if (arr.length == 0 || arr[0] == null) {
                return null;
            }
    
            root = new BinaryTreeNode(arr[0]);
            Queue&lt;BinaryTreeNode&gt; queue = new LinkedList&lt;&gt;();
            queue.add(root);
            int i = 1;
    
            // Traverse the input array and construct the binary tree
            while (!queue.isEmpty() &amp;&amp; i &lt; arr.length) {
                BinaryTreeNode currentNode = queue.poll();
    
                // Add left child
                if (arr[i] != null) {
                    currentNode.left = new BinaryTreeNode(arr[i]);
                    queue.add(currentNode.left);
                }
                i++;
    
                // Add right child
                if (i &lt; arr.length &amp;&amp; arr[i] != null) {
                    currentNode.right = new BinaryTreeNode(arr[i]);
                    queue.add(currentNode.right);
                }
                i++;
            }
            return root;
        }
    
        public static void main(String args[]) {
            Scanner sc = new Scanner(System.in);
            LonelyNodes ln = new LonelyNodes();
            Solution sol = new Solution();
    
            // Read input as space-separated integers, converting -1 to null for tree structure
            String[] inputStr = sc.nextLine().split(&quot; &quot;);
            Integer[] nodes = new Integer[inputStr.length];
            for (int i = 0; i &lt; inputStr.length; i++) {
                nodes[i] = inputStr[i].equals(&quot;-1&quot;) ? null : Integer.parseInt(inputStr[i]);
            }
    
            // Build the tree from input
            root = ln.buildTreeFromInput(nodes);
    
            // Get lonely nodes
            ArrayList&lt;Integer&gt; result = sol.getLonelyNodes(root);
    
            // Output result
            System.out.println(result);
        }
    }
    </code></pre><h2 id="15758fd8-d211-8060-92a9-c2a1dc2b7def" class=""><strong>Max_Area_of_Island</strong></h2><p id="15758fd8-d211-8091-8ebd-f44870198176" class="">Jadav Payeng, &quot;The Forest Man of India&quot;,<br/>started planting the seeds in a M*N grid land.<br/>Each cell in the grid land is planted with a seed.<br/>After few days, some seeds grow into saplings indicates with &#x27;1&#x27;,<br/>and the rest are dead seeds indicates with &#x27;0&#x27;.<br/></p><p id="15758fd8-d211-80b2-9fda-da95c75a68f8" class="">One or more saplings are connected either horizontally, vertically or diagonally with each other, form a sapling-group.<br/>There may be zero more sapling-groups in the grid land.<br/></p><p id="15758fd8-d211-8055-8d62-f1785ee9de62" class="">Jadav Payeng wants to know the biggest sapling-group in that grid land.</p><p id="15758fd8-d211-801a-bcc8-c703af4a9678" class="">You are given the M * N grid, filled with 0&#x27;s and 1&#x27;s.<br/>You are task is to help Jadav Payeng to find the number of saplings in<br/>the largest sapling-group.<br/></p><h2 id="15758fd8-d211-800a-9f0b-d78c746997f4" class="">Input Format:</h2><p id="15758fd8-d211-8079-99a0-c2dddcfb7cf8" class="">Line-1: Two integers M and N, the number of rows and columns in the grid-land.<br/>Next M lines: contains N space-separated integers .<br/></p><h2 id="15758fd8-d211-80b0-b888-cb07d849fb3a" class="">Output Format:</h2><p id="15758fd8-d211-806c-a4da-c74e0b993bd2" class="">Print an integer, the number of saplings in the<br/>largest sapling-group in the given grid-land.<br/></p><h2 id="15758fd8-d211-8020-bcd7-c95ce386dc91" class="">Sample Input-1:</h2><p id="15758fd8-d211-8041-a4f2-ff6dc68fc97e" class="">5 4<br/>0 0 1 1<br/>0 0 1 0<br/>0 1 1 0<br/>0 1 0 0<br/>1 1 0 0<br/></p><h2 id="15758fd8-d211-80be-80b3-e242c60c611f" class="">Sample Output-1:</h2><p id="15758fd8-d211-807b-b891-d2adcf7896ba" class="">8</p><h2 id="15758fd8-d211-8065-84a1-c3c936ef7557" class="">Sample Input-2:</h2><p id="15758fd8-d211-8040-9b8d-e0ec688cf54d" class="">5 5<br/>0 1 1 1 1<br/>0 0 0 0 1<br/>1 1 0 0 0<br/>1 1 0 1 1<br/>0 0 0 1 0<br/></p><h2 id="15758fd8-d211-803c-ac23-fa920b97983b" class="">Sample Output-2:</h2><p id="15758fd8-d211-804a-85f3-ca4158653104" class="">5</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="15758fd8-d211-8005-9312-e7e048026004" class="code"><code class="language-Java">import java.util.*;
    
    class Pair {
        int x;
        int y;
        Pair(int x, int y) {
            this.x = x;
            this.y = y;
        }
    }
    
    class Solution {
        static int[][] grid;
    
        static int BFS(int startX, int startY) {
            Queue&lt;Pair&gt; q = new LinkedList&lt;&gt;();
            q.offer(new Pair(startX, startY));
            int c = 1;
            grid[startX][startY] = 0;
            int[][] dir = new int[][] {{-1, 0}, {1, 0}, {0, -1}, {0, 1}, {-1, -1}, {-1, 1}, {1, -1}, {1, 1}};
            
            while (!q.isEmpty()) {
                Pair p = q.poll();
                int i_ind = p.x;
                int j_ind = p.y;
                
                for (int[] d : dir) {
                    int i = i_ind + d[0];
                    int j = j_ind + d[1];
                    
                    if (i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; i &lt; grid.length &amp;&amp; j &lt; grid[0].length &amp;&amp; grid[i][j] == 1) {
                        grid[i][j] = 0;
                        c++;
                        q.offer(new Pair(i, j));
                    }
                }
            }
            return c;
        }
    
        static int maxArea() {
            int maxA = 0;
            
            for (int i = 0; i &lt; grid.length; i++) {
                for (int j = 0; j &lt; grid[i].length; j++) {
                    if (grid[i][j] == 1) {
                        maxA = Math.max(maxA, BFS(i, j));
                    }
                }
            }
            return maxA;
        }
    
        public static void main(String[] args) {
            Scanner sc = new Scanner(System.in);
            int n = sc.nextInt();
            int m = sc.nextInt();
            grid = new int[n][m];
            
            for (int i = 0; i &lt; n; i++) {
                for (int j = 0; j &lt; m; j++) {
                    grid[i][j] = sc.nextInt();
                }
            }
            
            System.out.println(maxArea());
        }
    }
    </code></pre><h2 id="15758fd8-d211-8057-b02f-e2b1b5574309" class=""><strong>Max_Area_of_Island_DFS</strong></h2><p id="15758fd8-d211-803f-b65f-c10f0eac49ef" class="">Jadav Payeng, &quot;The Forest Man of India&quot;,<br/>started planting the seeds in a M*N grid land.<br/>Each cell in the grid land is planted with a seed.<br/>After few days, some seeds grow into saplings indicates with &#x27;1&#x27;,<br/>and the rest are dead seeds indicates with &#x27;0&#x27;.<br/></p><p id="15758fd8-d211-80bd-8f32-ea930bbc4216" class="">
    </p><p id="15758fd8-d211-8001-a5ae-e1b3ae14c21c" class="">One or more saplings are connected either horizontally, vertically or diagonally with each other, form a sapling-group.<br/>There may be zero more sapling-groups in the grid land.<br/></p><p id="15758fd8-d211-806f-ada4-f6cbbfff0d3a" class="">Jadav Payeng wants to know the biggest sapling-group in that grid land.</p><p id="15758fd8-d211-8074-923f-f063513deea7" class="">You are given the M * N grid, filled with 0&#x27;s and 1&#x27;s.<br/>You are task is to help Jadav Payeng to find the number of saplings in<br/>the largest sapling-group.<br/></p><h2 id="15758fd8-d211-806c-aef0-e8292b634500" class="">Input Format:</h2><p id="15758fd8-d211-8070-a074-d906ec9512cd" class="">Line-1: Two integers M and N, the number of rows and columns in the grid-land.<br/>Next M lines: contains N space-separated integers .<br/></p><h2 id="15758fd8-d211-80a4-995c-c27b67ed4656" class="">Output Format:</h2><p id="15758fd8-d211-8002-820b-df9b1b6cd919" class="">Print an integer, the number of saplings in the<br/>largest sapling-group in the given grid-land.<br/></p><h2 id="15758fd8-d211-809a-a333-d1d9011dd706" class="">Sample Input-1:</h2><p id="15758fd8-d211-80b4-85ca-e4adb872c424" class="">5 4<br/>0 0 1 1<br/>0 0 1 0<br/>0 1 1 0<br/>0 1 0 0<br/>1 1 0 0<br/></p><h2 id="15758fd8-d211-808b-aa66-cd6c7a551696" class="">Sample Output-1:</h2><p id="15758fd8-d211-8095-8b32-c7ab9aa56836" class="">8</p><h2 id="15758fd8-d211-8077-8087-c48e357a0430" class="">Sample Input-2:</h2><p id="15758fd8-d211-80aa-8771-cbf993b2a847" class="">5 5<br/>0 1 1 1 1<br/>0 0 0 0 1<br/>1 1 0 0 0<br/>1 1 0 1 1<br/>0 0 0 1 0<br/></p><h2 id="15758fd8-d211-808e-ba13-feafa3fdc8b0" class="">Sample Output-2:</h2><p id="15758fd8-d211-8056-a475-d4f6802309e4" class="">5</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="15758fd8-d211-803f-9acd-fd4fd93a2fa2" class="code"><code class="language-Java">import java.util.*;
    
    class Pair{
        int x;
        int y;
        Pair(int x,int y){
            this.x=x;
            this.y=y;
        }
    }
    
    class Solution{
        
        static int DFS(int arr[][], int start, int end)
        {
            int n=arr.length;
            int m=arr[0].length;
            Stack&lt;Pair&gt; s = new Stack&lt;&gt;();
            s.push(new Pair(start,end));
            int c=1;
            while(!s.isEmpty())
            {
                Pair p =s.pop();
                int x=p.x;
                int y=p.y;
                int dir[][]=new int[][]{{1,1},{1,-1},{-1,1},{-1,-1},{0,1},{1,0},{0,-1},{-1,0}};
                for(int i=0;i&lt;8;i++)
                {
                    int nr=x+dir[i][0];
                    int nc=y+dir[i][1];
                    if(nr&gt;=0 &amp;&amp; nc&gt;=0 &amp;&amp; nr&lt;n &amp;&amp; nc&lt;m &amp;&amp; arr[nr][nc]==1)
                    {
                        c++;
                        arr[nr][nc]=0;
                        s.push(new Pair(nr,nc));
                    }
                }
            }
            return c;
            
        }
        static void solve(int arr[][], int n,int m){
            int area=Integer.MIN_VALUE;
            for(int i=0;i&lt;n;i++){
                for(int j=0;j&lt;m;j++)
                {
                    if(arr[i][j]==1)
                    {
                        arr[i][j]=0;
                        area=Math.max(DFS(arr,i,j),area);
                    }
                }
            }
            System.out.println(area);
        }
        public static void main(String[] args){
            Scanner sc = new Scanner(System.in);
            int n = sc.nextInt();
            int m = sc.nextInt();
            int arr[][]=new int[n][m];
            for(int i=0;i&lt;n;i++){
                for(int j=0;j&lt;m;j++){
                    arr[i][j]=sc.nextInt();
                }
            }
            solve(arr,n,m);
        }
    }</code></pre><h2 id="15758fd8-d211-80b0-b5f3-fd590c79df8b" class=""><strong>Distinct_Islands_BFS</strong></h2><p id="15758fd8-d211-8016-ad82-c16bf8e7cfd0" class="">You are a wedding decorator responsible for decorating a wall of size M * N using two different colored balloons.<br/>The balloons can either be blue or white.<br/>The blue-colored balloons form distinct shapes, where each shape consists of blue balloons connected in one of the four cardinal directions (up, down, left, or right).<br/>White balloons serve as separators between blue balloon shapes.<br/></p><p id="15758fd8-d211-8025-a5d1-cb1fbfe76c99" class="">Blue-colored balloons are represented by the digit 1, while white-colored balloons are represented by the digit 0 in a 2D matrix.<br/>Your task is to count the number of distinct shapes formed by the blue balloons on the wall.<br/></p><p id="15758fd8-d211-806e-9d3e-e00a9c2176b7" class="">Two shapes are considered distinct if one shape cannot be exactly transformed into the other by shifting (translation).</p><h2 id="15758fd8-d211-80f8-b0df-cb5ae893fd67" class="">Input Format:</h2><p id="15758fd8-d211-804a-a54e-ec7c0a6e5699" class="">Line-1: Two space-separated integers M and N, representing the size of the wall (M rows and N columns).<br/>Line-2 to M: The next M lines each contain N space-separated integers, either 0 or 1, where 1 represents a blue balloon and 0 represents a white balloon.<br/></p><h2 id="15758fd8-d211-808c-a900-e61d0177d188" class="">Output Format:</h2><p id="15758fd8-d211-8095-ade7-ef4cac2b11c3" class="">Line-1: An integer representing the number of distinct shapes formed by blue balloons.</p><h2 id="15758fd8-d211-806b-bc81-c5e15818abcc" class="">Constraints:</h2><ul id="15758fd8-d211-80e9-a6ff-e30186b9b8a3" class="bulleted-list"><li style="list-style-type:disc">1 ≤ M, N ≤ 50<br/>*The matrix consists only of 0s and 1s.<br/></li></ul><h2 id="15758fd8-d211-802f-864e-c54f5dfd8a66" class="">Sample Input-1:</h2><p id="15758fd8-d211-80a8-a1af-e6fc5d5e1343" class="">4 5<br/>1 1 0 0 0<br/>1 1 0 0 0<br/>0 0 0 1 1<br/>0 0 0 1 1<br/></p><h2 id="15758fd8-d211-80d1-8197-fc56e83c4a9f" class="">Sample Output-1:</h2><p id="15758fd8-d211-80b9-bd49-d2f7da58c1cb" class="">1</p><h2 id="15758fd8-d211-80ba-80e1-ffa5d3066cd2" class="">Explanation:</h2><p id="15758fd8-d211-809c-a9f1-f48d91e09599" class="">In the given input, two shapes are formed by blue balloons. However, both shapes are identical in form, so the output is 1.</p><h2 id="15758fd8-d211-80a1-b9b9-ea2da0f0e957" class="">Sample Input-2:</h2><p id="15758fd8-d211-808b-9283-e726f9a04f84" class="">5 5<br/>1 1 0 1 1<br/>1 0 0 0 1<br/>0 0 0 0 0<br/>1 0 0 0 1<br/>1 1 0 1 1<br/></p><h2 id="15758fd8-d211-8071-89fa-d5641be9ce9b" class="">Sample Output-2:</h2><p id="15758fd8-d211-803b-903d-d79ee0bd4ac4" class="">4</p><h2 id="15758fd8-d211-802c-a3b1-d82f7786ce06" class="">Explanation:</h2><p id="15758fd8-d211-80b9-96c1-f9057dd2627b" class="">There are four distinct shapes formed by the blue balloons.</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="15758fd8-d211-80a0-a87d-d9957233c92a" class="code"><code class="language-Java">import java.util.*;
    
    class Pair{
        int x;
        int y;
        Pair(int x, int y){
            this.x=x;
            this.y=y;
        }
    }
    
    class Solution{
        
        static String BFS(int arr[][], int start, int end)
        {
            int n=arr.length;
            int m=arr[0].length;
            Queue&lt;Pair&gt; q=new LinkedList&lt;&gt;();
            q.offer(new Pair(start,end));
            String s=&quot;&quot;;
            int j=0;
            while(!q.isEmpty())
            {
                Pair p = q.poll();
                int x = p.x;
                int y=p.y;
                int dir[][]= new int[][]{{0,-1},{-1,0},{0,1},{1,0}};
                String path[] = new String[]{&quot;l&quot;,&quot;u&quot;,&quot;r&quot;,&quot;d&quot;};
                for(int i=0;i&lt;4;i++){
                    int nr=x+dir[i][0];
                    int nc=y+dir[i][1];
                    if(nr&gt;=0 &amp;&amp; nc&gt;=0 &amp;&amp; nr&lt;n &amp;&amp; nc&lt;m &amp;&amp; arr[nr][nc]==1)
                    {
                        arr[nr][nc]=0;
                        q.offer(new Pair(nr,nc));
                        if(j==0)
                        {
                            for(int k=0;k&lt;4;k++){
                                path[k]=&quot;c&quot;+path[k];
                            }
                            j++;
                        }
                        else
                        {
                            for(int k=0;k&lt;4;k++){
                                path[k]=s.charAt(s.length()-1)+path[k];
                            }
                        }
                        s+=path[i];
                    }
                }
            }
            return s;
        }
        
        static void solve(int [][]arr){
            HashSet&lt;String&gt; ans = new HashSet&lt;&gt;();
            for(int i=0;i&lt;arr.length;i++)
            {
                for(int j=0;j&lt;arr[0].length;j++)
                {
                    if(arr[i][j]==1)
                    {
                        arr[i][j]=0;
                        ans.add(BFS(arr,i,j));
                    }
                }
            }
            System.out.println(ans.size());
        }
        public static void main(String[] args){
            Scanner sc = new Scanner(System.in);
            int n=sc.nextInt();
            int m=sc.nextInt();
            int arr[][]=new int[n][m];
            for(int i=0;i&lt;n;i++){
                for(int j=0;j&lt;m;j++){
                    arr[i][j]=sc.nextInt();
                }
            }
            solve(arr);
        }
    }</code></pre><h2 id="15758fd8-d211-8004-8d4e-d044d6322bd6" class=""><strong>Distinct_Islands_DFS</strong></h2><p id="15758fd8-d211-80f4-912b-cb99800e0433" class="">Pranav has a puzzle board filled with square boxes in the form of a grid.<br/>Some cells in the grid may be empty. &#x27;0&#x27; - indicates empty, &#x27;1&#x27; - indicates a box.<br/></p><p id="15758fd8-d211-806b-b998-e6ab839d60fb" class="">The puzzle board has some patterns formed with boxes in it,<br/>the patterns may be repeated. The patterns are formed with boxes (1&#x27;s) only,<br/>that are connected horizontally and vertically but not diagonally.<br/></p><p id="15758fd8-d211-8054-b595-d0c73aee4c1c" class="">Pranav wants to find out the number of unique patterns in the board.</p><p id="15758fd8-d211-8043-ad79-fd0a459440e5" class="">You are given the board in the form of a grid M*N, filled wth 0&#x27;s and 1&#x27;s.<br/>Your task is to help Pranav to find the number of unique patterns in the puzzle board.<br/></p><h2 id="15758fd8-d211-801d-8e28-cdba47dffbc1" class="">Input Format:</h2><p id="15758fd8-d211-80c6-b041-e4f59b9058ba" class="">Line-1: Two integers M and N, the number of rows and columns in the grid-land.<br/>Next M lines: contains N space-separated characters [&#x27;0&#x27;,&#x27;1&#x27;].<br/></p><h2 id="15758fd8-d211-8072-b5f6-e876ae03a9f1" class="">Output Format:</h2><p id="15758fd8-d211-8086-997d-d7aa4c3003e1" class="">Print an integer, the number of unique patterns in the puzzle board.</p><h2 id="15758fd8-d211-8089-a485-f11821afa364" class="">Sample Input-1:</h2><p id="15758fd8-d211-8029-a7d0-de0cb40c83a4" class="">5 5<br/>0 1 0 1 1<br/>1 1 1 0 1<br/>0 1 0 1 0<br/>1 0 1 1 1<br/>1 1 0 1 0<br/></p><h2 id="15758fd8-d211-8007-8a82-c667eee4eeae" class="">Sample Output-1:</h2><p id="15758fd8-d211-800b-b158-fcbf27224fc1" class="">3</p><h2 id="15758fd8-d211-803a-b699-d200720446d3" class="">Explanation-1:</h2><p id="15758fd8-d211-803f-91b3-c0a16793df77" class="">The unique patterns are as follows:<br/>1			 1 1		1<br/>1 1 1		   1  	,	1 1<br/>1		,<br/></p><h2 id="15758fd8-d211-80e6-a4ab-f01e6222beb5" class="">Sample Input-2:</h2><p id="15758fd8-d211-8005-a32a-dc46370d24ee" class="">6 6<br/>1 1 0 0 1 1<br/>1 0 1 1 0 1<br/>0 1 0 1 0 0<br/>1 1 0 0 0 1<br/>0 0 1 0 1 1<br/>1 1 0 1 0 0<br/></p><h2 id="15758fd8-d211-8059-9b6a-c04e6023ae8c" class="">Sample Output-2:</h2><p id="15758fd8-d211-8088-a11c-e211a3f7d3da" class="">5</p><h2 id="15758fd8-d211-8083-9ad6-e31588917437" class="">Explanation-2:</h2><p id="15758fd8-d211-8014-a526-e43be7519fba" class="">The unique patterns are as follows:<br/>1 1		1 1		    1			1 1 	1<br/>1   	  1         1 1<br/></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="15758fd8-d211-8060-8c4a-fd3138270bab" class="code"><code class="language-Java">import java.util.*;
    
    class Pair{
        int x;
        int y;
        Pair(int x, int y){
            this.x=x;
            this.y=y;
        }
    }
    
    class Solution{
        
        static String DFS(int arr[][], int start, int end)
        {
            int n=arr.length;
            int m=arr[0].length;
            Stack&lt;Pair&gt; st=new Stack&lt;&gt;();
            st.push(new Pair(start,end));
            String s=&quot;&quot;;
            while(!st.isEmpty())
            {
                Pair p = st.pop();
                int x = p.x;
                int y=p.y;
                int dir[][]= new int[][]{{0,-1},{-1,0},{0,1},{1,0}};
                String path[] = new String[]{&quot;l&quot;,&quot;u&quot;,&quot;r&quot;,&quot;d&quot;};
                for(int i=0;i&lt;4;i++){
                    int nr=x+dir[i][0];
                    int nc=y+dir[i][1];
                    if(nr&gt;=0 &amp;&amp; nc&gt;=0 &amp;&amp; nr&lt;n &amp;&amp; nc&lt;m &amp;&amp; arr[nr][nc]==1)
                    {
                        arr[nr][nc]=0;
                        st.push(new Pair(nr,nc));
                        s+=path[i];
                    }
                    else
                    {
                        s+=&quot;b&quot;;
                    }
                }
            }
            return s;
        }
        
        static void solve(int [][]arr){
            HashSet&lt;String&gt; ans = new HashSet&lt;&gt;();
            for(int i=0;i&lt;arr.length;i++)
            {
                for(int j=0;j&lt;arr[0].length;j++)
                {
                    if(arr[i][j]==1)
                    {
                        arr[i][j]=0;
                        ans.add(DFS(arr,i,j));
                    }
                }
            }
            System.out.println(ans.size());
        }
        public static void main(String[] args){
            Scanner sc = new Scanner(System.in);
            int n=sc.nextInt();
            int m=sc.nextInt();
            int arr[][]=new int[n][m];
            for(int i=0;i&lt;n;i++){
                for(int j=0;j&lt;m;j++){
                    arr[i][j]=sc.nextInt();
                }
            }
            solve(arr);
        }
    }</code></pre><h2 id="15758fd8-d211-80c4-b2e2-d6328a80fc05" class=""><strong>The_Maze</strong></h2><p id="15758fd8-d211-8062-a0f8-e7b7c10f89fa" class="">You are given an N×N grid that represents a maze.<br/>In this maze: Each cell contains either a 0 or 1.<br/>--1 indicates an open path where you can walk.<br/>--0 indicates a dead-end where you cannot pass.<br/></p><p id="15758fd8-d211-8001-bb94-c4a00b3d4c29" class="">You start at the top-left corner of the maze, i.e., position (0, 0).<br/>Your target is to reach the bottom-right corner of the maze, i.e., position (N-1, N-1).<br/>In the maze, you can move only right or down from each cell.<br/></p><p id="15758fd8-d211-80fb-b40d-f0fb925275db" class="">Objective: Determine if there exists a path from the start (0, 0) to the end (N-1, N-1) that passes only through cells marked 1.<br/>If such a path exists, return true; otherwise, return false.<br/></p><h2 id="15758fd8-d211-80f7-9370-c1153702478b" class="">Input Format:</h2><p id="15758fd8-d211-806e-8e0f-d71eff0037bc" class="">Line-1: The first line contains an integer N, the size of the square grid.<br/>Line 2 to N: The next N lines each contain N space-separated integers (either 0 or 1), representing the maze.<br/></p><h2 id="15758fd8-d211-8016-9c30-e7f98a1b94e4" class="">Output Format:</h2><p id="15758fd8-d211-80c1-b005-f36d9bec248a" class="">Line-1: Print true if a path exists from (0, 0) to (N-1, N-1), otherwise print false.</p><h2 id="15758fd8-d211-80bd-863b-cb6d1445dca4" class="">Constraints:</h2><ul id="15758fd8-d211-80aa-a61b-ca4090dd131f" class="bulleted-list"><li style="list-style-type:disc">1 ≤ N ≤ 100</li></ul><ul id="15758fd8-d211-80fe-a60a-c4c41e7e073a" class="bulleted-list"><li style="list-style-type:disc">Each cell in the grid is either 0 or 1.</li></ul><h2 id="15758fd8-d211-803d-a1b1-f865a2558608" class="">Sample Input-1:</h2><p id="15758fd8-d211-808b-8763-d9ecf54b0ff8" class="">4<br/>1 0 0 0<br/>1 1 0 1<br/>0 1 0 0<br/>1 1 1 1<br/></p><h2 id="15758fd8-d211-80c8-a0b9-cc4728f5471c" class="">Sample Output-1:</h2><p id="15758fd8-d211-8022-a294-cc69f8924614" class="">true</p><p id="15758fd8-d211-809e-ae4b-fa239a32287a" class="">Explanation: There exists a path from (0, 0) to (3, 3).</p><h2 id="15758fd8-d211-80f7-b4b3-eb2ce41f6417" class="">Sample Input-2:</h2><p id="15758fd8-d211-8069-94f9-ddb7cbb6e02f" class="">4<br/>1 1 0 0<br/>1 0 0 1<br/>0 1 1 0<br/>1 0 0 1<br/></p><h2 id="15758fd8-d211-80e8-8151-f1418d2152eb" class="">Sample Output-2:</h2><p id="15758fd8-d211-80b2-8d6f-da77531d4f16" class="">false</p><p id="15758fd8-d211-8073-adea-cb6ac7dc333b" class="">Explanation: There is no valid path from (0, 0) to (3, 3).</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="15758fd8-d211-800b-a803-dea590e39ab7" class="code"><code class="language-Java">import java.util.*;
    
    class Pair {
        int x;
        int y;
        
        Pair(int x, int y) {
            this.x = x;
            this.y = y;
        }
    }
    
    class Solution {
        static boolean solve(int arr[][]) {
            if(arr.length==1 &amp;&amp; arr[0][0]==1) return true;
            if (arr[0][0] == 0) return false;
            int n = arr.length;
            
            Queue&lt;Pair&gt; q = new LinkedList&lt;&gt;();
            q.offer(new Pair(0, 0));
            
            int dir[][] = new int[][]{{0, 1}, {1, 0}};
            
            while (!q.isEmpty()) {
                Pair p = q.poll();
                int x = p.x;
                int y = p.y;
                
                for (int i = 0; i &lt; 2; i++) {
                    int nr = x + dir[i][0];
                    int nc = y + dir[i][1];
    
                    if (nr == n - 1 &amp;&amp; nc == n - 1 &amp;&amp; arr[nr][nc] == 1) return true;
                    if (nr &gt;= 0 &amp;&amp; nc &gt;= 0 &amp;&amp; nr &lt; n &amp;&amp; nc &lt; n &amp;&amp; arr[nr][nc] == 1) {
                        q.offer(new Pair(nr, nc));
                        arr[nr][nc] = 0;
                    }
                }
            }
            
            return false;
        }
        
        public static void main(String[] args) {
            Scanner sc = new Scanner(System.in);
            int n = sc.nextInt();
            int arr[][] = new int[n][n];
            
            for (int i = 0; i &lt; n; i++) {
                for (int j = 0; j &lt; n; j++) {
                    arr[i][j] = sc.nextInt();
                }
            }
            
            System.out.println(solve(arr));
        }
    }
    </code></pre><h2 id="15758fd8-d211-804a-b521-c2035f52f971" class=""><strong>Boundary_of_Binary_Tree</strong></h2><p id="15758fd8-d211-8055-806a-d89ac3e6db99" class="">You are tasked with building a protective boundary around a series of military camps situated along the border, represented as a binary tree structure.<br/>Each node in this binary tree represents a military camp identified by a unique ID.<br/>The main base camp is the root of this binary tree, with connections to other camps.<br/></p><p id="15758fd8-d211-802c-88c4-e6c983b30237" class="">The goal is to help the Indian Army establish a secure boundary (S.H.I.E.L.D) around these camps.<br/>This boundary should be defined by the camps located at the edge of the binary tree, traced in an anti-clockwise direction, starting from the root.<br/></p><p id="15758fd8-d211-807f-915a-c05bf5b16f3a" class="">The boundary should include:<br/>-Left Boundary: The camps forming the left edge of the tree, excluding leaf camps.<br/>-Leaf Nodes: All camps that are leaf nodes, traversed from left to right.<br/>-Right Boundary: The camps forming the right edge of the tree, excluding the root and leaf camps, added in reverse order.<br/></p><p id="15758fd8-d211-80c8-8e78-c8499b8b7d26" class="">You need to implement a method that outputs the IDs of the military camps located on this boundary.</p><h2 id="15758fd8-d211-8006-856e-fde743bcf2f2" class="">Input Format:</h2><p id="15758fd8-d211-8053-89d7-ddd88354370a" class="">Line-1: Space-separated integers representing the IDs of the military camps in level order (top to bottom, left to right). Use -1 to denote a null or missing node.</p><h2 id="15758fd8-d211-8019-9100-e1488fe906e7" class="">Output Format:</h2><p id="15758fd8-d211-8044-b52a-dbf381d2b4ed" class="">Line-1: A list of integers representing the military camp IDs that form the boundary, in anti-clockwise order.</p><h2 id="15758fd8-d211-80c9-9313-e81cee696d81" class="">Constraints:</h2><ul id="15758fd8-d211-80d4-b718-d9f7373f4637" class="bulleted-list"><li style="list-style-type:disc">The tree may have between 1 and 10,000 nodes.</li></ul><ul id="15758fd8-d211-802a-8ca5-feb58c14ff79" class="bulleted-list"><li style="list-style-type:disc">Camp IDs are unique integers.</li></ul><ul id="15758fd8-d211-8030-858e-ec6454047ce1" class="bulleted-list"><li style="list-style-type:disc">1 indicates a missing (null) node.</li></ul><h2 id="15758fd8-d211-8009-a22e-e7437e80c481" class="">Sample Input-1:</h2><p id="15758fd8-d211-808e-adb0-c3a1d3c93e2b" class="">5 2 4 7 9 8 1</p><h2 id="15758fd8-d211-80ce-aefd-d90b6d28a5b7" class="">Sample Output-1:</h2><p id="15758fd8-d211-8022-915a-e31f38cbb3a6" class="">[5, 2, 7, 9, 8, 1, 4]</p><h2 id="15758fd8-d211-80ad-be9d-d559ca29da62" class="">Sample Input-2:</h2><p id="15758fd8-d211-8057-ba76-f14131a8611f" class="">11 2 13 4 25 6 -1 -1 -1 7 18 9 10</p><h2 id="15758fd8-d211-80f2-ab30-fc78f9d47a5f" class="">Sample Output-2:</h2><p id="15758fd8-d211-80d7-b8de-e6b0b9b43772" class="">[11, 2, 4, 7, 18, 9, 10, 6, 13]</p><h2 id="15758fd8-d211-8007-8c8e-ca129a5ad245" class="">Sample Input-3:</h2><p id="15758fd8-d211-806a-8dfa-d2a786567896" class="">1</p><h2 id="15758fd8-d211-80c2-89d5-ceb10f25fae1" class="">Sample Output-3:</h2><p id="15758fd8-d211-807d-951b-d42d8cee5c96" class="">[1]</p><h2 id="15758fd8-d211-80c2-a3dd-c1498d612e21" class="">NOTE:</h2><p id="15758fd8-d211-80ad-b7bc-ce0d21e054fb" class="">The input should be parsed and constructed into a binary tree, and your code should handle large trees efficiently.<br/>The boundary traversal should be handled with care, ensuring leaf nodes are only counted once in the output list.<br/></p><h2 id="15758fd8-d211-801b-9404-d503f2731b35" class="">Function Signature:</h2><p id="15758fd8-d211-8055-a0f8-f10f4f9361f0" class="">public List&lt;Integer&gt; boundaryOfBinaryTree(BinaryTreeNode root)</p><p id="15758fd8-d211-80e3-8a2b-f788ea3c5a04" class="">This function will return a list of integers representing the boundary nodes of the tree in anti-clockwise order.</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="15758fd8-d211-80fd-bae9-dec8c59c826a" class="code"><code class="language-Java">import java.util.*;
    
    class BinaryTreeNode
    {
        public int data; 
        public BinaryTreeNode left, right; 
        public BinaryTreeNode(int data)
        {
            this.data = data; 
            left = null; 
            right = null; 
        }
    }
    
    class Solution
    {
        void inorder(BinaryTreeNode root, List&lt;Integer&gt; nodes) {
            if(root == null || root.data == -1) {
                return;
            }
    
            if(root.left == null &amp;&amp; root.right == null) {
                if(root.data != -1) nodes.add(root.data);
                return;
            }
    
            inorder(root.left, nodes);
            inorder(root.right, nodes);
        }
    
        void bfs(BinaryTreeNode root, List&lt;Integer&gt; nodes, int f) {    
            Queue&lt;BinaryTreeNode&gt; q = new LinkedList&lt;&gt;();
    
            if(root == null) return;
            if(root.left != null) {
                q.add(root.left);
            }
            if(root.right != null) {
                q.add(root.right);
            }
    
            List&lt;Integer&gt; rn = new ArrayList&lt;&gt;();
    
            while(!q.isEmpty()) {
                int n = q.size();
    
                for(int i = 0; i &lt; n; i++) {
                    BinaryTreeNode temp = q.remove();
                    if(temp.left == null &amp;&amp; temp.right == null) {
                        continue;
                    }
                    if(f == 0 &amp;&amp; i == 0 &amp;&amp; temp.data != -1) nodes.add(temp.data); 
                    if(f == 1 &amp;&amp; i == n - 1 &amp;&amp; temp.data != -1) rn.add(temp.data);
                    if(temp.left != null &amp;&amp; temp.left.data != -1) {
                        q.add(temp.left);
                    }
                    if(temp.right != null &amp;&amp; temp.right.data != -1) {
                        q.add(temp.right);
                    }
                }
            }
    
            for(int i = rn.size() - 1; i &gt;= 0; i--) {
                nodes.add(rn.get(i));
            }
        }
    
        List&lt;Integer&gt; nodes = new ArrayList&lt;&gt;();
        public List&lt;Integer&gt; boundaryOfBinaryTree(BinaryTreeNode root) {
            //Write your code here and return list of nodes
            List&lt;Integer&gt; nodes = new ArrayList&lt;&gt;();
            nodes.add(root.data);
            if(root.left == null &amp;&amp; root.right == null) {
                return nodes;
            }
            bfs(root, nodes, 0);
            inorder(root, nodes);
            bfs(root, nodes, 1);
            return nodes;
        }
        //Your supporting methods if any goes here
    }
    
    public class BoundaryOfBinaryTree
    {
        static BinaryTreeNode root;
        void insert(BinaryTreeNode temp, int key){ 
            if (temp == null) {
                temp = new BinaryTreeNode(key);
                return;
            }
            Queue&lt;BinaryTreeNode&gt; q = new LinkedList&lt;BinaryTreeNode&gt;();
            q.add(temp);
     
            // Do level order traversal until we find an empty place.
            while (!q.isEmpty()) {
                temp = q.remove();
     
                if (temp.left == null) {
                    temp.left = new BinaryTreeNode(key);
                    break;
                }
                else
                    q.add(temp.left);
     
                if (temp.right == null) {
                    temp.right = new BinaryTreeNode(key);
                    break;
                }
                else
                    q.add(temp.right);
            }
        }
    
        public static void main(String args[]){
            Scanner sc=new Scanner(System.in);
            BoundaryOfBinaryTree bbt=new BoundaryOfBinaryTree();
            Solution sol= new Solution();
            
            String str[]=sc.nextLine().split(&quot; &quot;);
    
            root=new BinaryTreeNode(Integer.parseInt(str[0]));
    
            for(int i=1; i&lt;str.length; i++)
                bbt.insert(root,Integer.parseInt(str[i]));
    
            System.out.println(sol.boundaryOfBinaryTree(root));
        }
    }</code></pre><h2 id="15758fd8-d211-8048-b0bd-d41df518fdcd" class=""><strong>Symmetric_Tree</strong></h2><p id="15758fd8-d211-80b9-a11c-caedf286a23e" class="">Ramesh is interested to work on Data Structures.<br/>He has constructed BinaryTree-BT.<br/></p><p id="15758fd8-d211-8024-8b48-e5e9bf7bc7aa" class="">He asked his friend Gopal to check whether BT is self mirror tree or not.<br/>Can you help Gopal to find and return &quot;true&quot; if BT is a self mirror tree,<br/>otherwise return &quot;false&quot;<br/></p><p id="15758fd8-d211-80f0-95ca-d7b37f101ee2" class="">Implement the class Solution:</p><ol type="1" id="15758fd8-d211-8060-84d9-e98881871181" class="numbered-list" start="1"><li>public boolean isSelfMirrorTree(BinaryTreeNode root): returns a boolean value.</li></ol><p id="15758fd8-d211-800c-bffc-f5edb57cd10c" class="">NOTE:<br/>- In the tree &#x27;-1&#x27;, indicates empty(null).<br/></p><h2 id="15758fd8-d211-8007-81df-d65df1503027" class="">Input Format:</h2><p id="15758fd8-d211-8017-babd-fb9ccb3cfcf7" class="">Line-1: Space separated integers, values at the treenode</p><h2 id="15758fd8-d211-8053-b459-d54e9b7c6370" class="">Output Format:</h2><p id="15758fd8-d211-80b0-a375-f4bd9431e3ba" class="">Line-1: Print a boolean value.</p><h2 id="15758fd8-d211-80c6-9ac6-f31eb747c4ab" class="">Sample Input-1:</h2><p id="15758fd8-d211-8089-b6f5-f1b0c7fcefeb" class="">2 1 1 2 3 3 2</p><h2 id="15758fd8-d211-807e-ac81-f1187aae938c" class="">Sample Output-1:</h2><p id="15758fd8-d211-8054-bdeb-de9d048ca569" class="">true</p><h2 id="15758fd8-d211-8097-b801-dbdf12a46809" class="">Sample Input-2:</h2><p id="15758fd8-d211-800e-b2e8-d827ccfd776a" class="">2 1 1 -1 3 -1 3</p><h2 id="15758fd8-d211-802f-97e0-e6638bede07b" class="">Sample Output-2:</h2><p id="15758fd8-d211-8003-b0e5-d86186560756" class="">false</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="15758fd8-d211-801b-9520-c6aea42d1cd1" class="code"><code class="language-Java">import java.util.*;
    
    class BinaryTreeNode{
        public int data; 
        public BinaryTreeNode left, right; 
        public BinaryTreeNode(int data){
            this.data = data; 
            left = null; 
            right = null; 
        }
    }
    
    class Solution{
        //Write your code here and return boolean value
        
        public boolean isBalanced(BinaryTreeNode root1, BinaryTreeNode root2)
        {
            if(root1==null &amp;&amp; root2==null) return true;
            if(root1==null || root2==null) return false;
            if(root1.data!=root2.data) return false;
            return isBalanced(root1.left,root2.right) &amp;&amp; isBalanced(root1.right,root2.left);
        }
        public boolean isSymmetric(BinaryTreeNode r)
        {
            return isBalanced(r.left,r.right);
        }
    }
    
    public class SymmetricTree{
        static BinaryTreeNode root;
        static BinaryTreeNode temp = root;
        void insert(BinaryTreeNode temp, int key){ 
            if (temp == null) {
                root = new BinaryTreeNode(key);
                return;
            }
            Queue&lt;BinaryTreeNode&gt; q = new LinkedList&lt;BinaryTreeNode&gt;();
            q.add(temp);
     
            // Do level order traversal until we find an empty place.
            while (!q.isEmpty()) {
                temp = q.remove();
     
                if (temp.left == null) {
                    temp.left = new BinaryTreeNode(key);
                    break;
                }
                else
                    q.add(temp.left);
     
                if (temp.right == null) {
                    temp.right = new BinaryTreeNode(key);
                    break;
                }
                else
                    q.add(temp.right);
            }
        }
    
        public static void main(String args[]){
            Scanner sc=new Scanner(System.in);
            String str[]=sc.nextLine().split(&quot; &quot;);
            SymmetricTree st=new SymmetricTree();
            root=new BinaryTreeNode(Integer.parseInt(str[0]));
            for(int i=1; i&lt;str.length; i++)
                st.insert(root,Integer.parseInt(str[i]));
            Solution sol= new Solution();
            System.out.println(sol.isSymmetric(root));
        }
    }</code></pre><h2 id="15758fd8-d211-80fb-923e-e36794799c92" class=""><strong>Balanced_Binary_Tree</strong></h2><p id="15758fd8-d211-8061-ac52-c60ecf0c4342" class="">Mr. Rishil is interested to work on Data Structures.<br/>He has constructed a BinaryTree-BT.<br/></p><p id="15758fd8-d211-80c1-bf02-eb3f04042b2f" class="">He asked his friend Mr. Anil to check whether BT is a balanced BT or not.<br/>A balanced BT is defined as follows:<br/>- The binary tree in which the left and right subtrees of every node<br/>differ in height by no more than 1.<br/></p><p id="15758fd8-d211-8086-8fc5-dba442ed70f9" class="">Can you help Mr. Anil to find and return &quot;true&quot; if the given BT is a balanced tree,<br/>otherwise return &quot;false&quot;.<br/></p><p id="15758fd8-d211-8056-8954-eba783ea7f1c" class="">Implement the class Solution:</p><ol type="1" id="15758fd8-d211-808f-96d5-cc41604587e7" class="numbered-list" start="1"><li>public boolean isBalanced(BinaryTreeNode root): returns a boolean value.</li></ol><p id="15758fd8-d211-8074-9828-fd3ab543a4c8" class="">NOTE:<br/>- In the tree &#x27;-1&#x27;, indicates empty(null).<br/></p><h2 id="15758fd8-d211-80fd-a58a-cc43c67680e3" class="">Input Format:</h2><p id="15758fd8-d211-80cc-8c9f-e6cf2469d08d" class="">Line-1: Space separated integers, values at the treenode</p><h2 id="15758fd8-d211-8039-b515-d32f3fa3a4dc" class="">Output Format:</h2><p id="15758fd8-d211-80fc-b2b7-fc467cb591cb" class="">Line-1: A boolean value.</p><h2 id="15758fd8-d211-80d0-8f84-d366df5af64a" class="">Sample Input-1:</h2><p id="15758fd8-d211-80a1-baca-e52c4f0eac3c" class="">2 1 1 2 3 3 2</p><h2 id="15758fd8-d211-8038-ac29-d50067b01fbf" class="">Sample Output-1:</h2><p id="15758fd8-d211-806e-ae3a-f1d0ba0bb254" class="">true</p><h2 id="15758fd8-d211-8096-82ab-d3e5eace2b9a" class="">Sample Input-2:</h2><p id="15758fd8-d211-8017-af45-d2271d2640d0" class="">1 2 3 4 5 -1 -1 6 7</p><h2 id="15758fd8-d211-807e-bea0-f7f2c2c16360" class="">Sample Output-2:</h2><p id="15758fd8-d211-8041-9809-fdf4b75c2386" class="">false</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="15758fd8-d211-80d7-8a30-ece46bd9bde1" class="code"><code class="language-Java">import java.util.*;
    
    class BinaryTreeNode
    {
        public int data; 
        public BinaryTreeNode left, right; 
        public BinaryTreeNode(int data)
        {
            this.data = data; 
            left = null; 
            right = null; 
        }
    }
    
    class Solution 
    {
       public boolean isBalanced(BinaryTreeNode root) 
        {
            //Write your code here and return a boolean value
            if(root==null) return true;
            return findBalanced(root);
        }
    
        //Your supporting methods(if any) goes here
        public boolean findBalanced(BinaryTreeNode root) {
            if(root==null || root.data == -1) return true;
            int lh = findHeight(root.left);
            int rh = findHeight(root.right);
            if(Math.abs(lh-rh)&gt;1) return false;
            return findBalanced(root.left) &amp;&amp; findBalanced(root.right);
        }
        public int findHeight(BinaryTreeNode root) {
            if(root==null || root.data == -1) {
                return 0;
            }
            int lh = findHeight(root.left);
            int rh = findHeight(root.right);
            return Math.max(lh, rh) + 1;
        }
    
        //Your supporting methods(if any) goes here
    }
    
    public class BalancedBinaryTree
    {
        static BinaryTreeNode root;
        void insert(BinaryTreeNode temp, int key)
        { 
            if (temp == null) 
            {
                temp = new BinaryTreeNode(key);
                return;
            }
            Queue&lt;BinaryTreeNode&gt; q = new LinkedList&lt;BinaryTreeNode&gt;();
            q.add(temp);
     
            // Do level order traversal until we find an empty place.
            while (!q.isEmpty()) {
                temp = q.remove();
     
                if (temp.left == null) {
                    temp.left = new BinaryTreeNode(key);
                    break;
                }
                else
                    q.add(temp.left);
     
                if (temp.right == null) {
                    temp.right = new BinaryTreeNode(key);
                    break;
                }
                else
                    q.add(temp.right);
            }
        }
    
        public static void main(String args[])
        {
            Scanner sc=new Scanner(System.in);
            BalancedBinaryTree ln=new BalancedBinaryTree();
            Solution sol= new Solution();
            
            String str[]=sc.nextLine().split(&quot; &quot;);
            root=new BinaryTreeNode(Integer.parseInt(str[0]));
            for(int i=1; i&lt;str.length; i++)
                ln.insert(root,Integer.parseInt(str[i]));
    
            System.out.println(sol.isBalanced(root));
        }
    }
    </code></pre><h2 id="15758fd8-d211-8087-a524-e166adf99372" class=""><strong>Average_Levels_Binary_Tree</strong></h2><p id="15758fd8-d211-8032-a31f-e7cdd209f2fb" class="">For X-Mas, santa claus is preparing a X-Mas Tree with set of Bulbs.<br/>The bulbs are of different voltages, and preparation of tree as follows:<br/>- The bulbs are arranged in level-wise, levels are numbered from 0,1,2,3..<br/>so on.<br/>- At level-0: There will be only one bulb as root bulb.,<br/>- From next level onwards, we can attach atmost two bulbs, one is to left side<br/>and/or the other is to right side of every bulb in previous level.<br/>- The empty attachements in a level are indicated with -1.<br/></p><p id="15758fd8-d211-800c-b556-dddaa84fc583" class="">You will be given the X-Mas Tree root,<br/>Your task is to findout the average of each level of the X-Mas tree, starts from level-0.<br/></p><p id="15758fd8-d211-8089-9a16-ef60de3552f8" class="">Implement the class Solution.<br/>1.public boolean averageOfLevels(BinaryTreeNode root): returns a boolean value.<br/></p><h2 id="15758fd8-d211-8010-9f5f-e7433071299c" class="">Input Format:</h2><p id="15758fd8-d211-8018-9a74-f7f19fe38c53" class="">A single line of space separated integers, voltages of the set of bulbs.</p><h2 id="15758fd8-d211-80f3-ae91-e3aaa9d0353b" class="">Output Format:</h2><p id="15758fd8-d211-801e-99d1-efc1de622a2a" class="">Print a list of double values (averages of each level)</p><h2 id="15758fd8-d211-8058-a7de-d30a4dc37e5a" class="">Sample Input-1:</h2><p id="15758fd8-d211-80a8-95c8-ea980ed3509b" class="">3 8 4 3 5 -1 7</p><h2 id="15758fd8-d211-806a-8456-f6f9bcba789d" class="">Sample Output-1:</h2><p id="15758fd8-d211-803a-9f85-c5142f3106fd" class="">[3.0, 6.0, 5.0]</p><h2 id="15758fd8-d211-806f-a84d-f1236d8cc8cb" class="">Sample Input-2:</h2><p id="15758fd8-d211-80ea-82ba-c1e2a06e3941" class="">3 8 4 3 5 7 7</p><h2 id="15758fd8-d211-80af-8477-f34918983beb" class="">Sample Output-2:</h2><p id="15758fd8-d211-80f8-8f43-c08544fd6fd9" class="">[3.0, 6.0, 5.5]</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="15758fd8-d211-80a6-b766-c2557cf2bc3b" class="code"><code class="language-Java">import java.util.*;
    
    class BinaryTreeNode
    {
        public int data; 
        public BinaryTreeNode left, right; 
        public BinaryTreeNode(int data){
            this.data = data; 
            left = null; 
            right = null; 
        }
    }
    
    class Solution 
    {
        public List&lt;Double&gt; averageOfLevels(BinaryTreeNode root) 
        {
            //Write your code here and return a list
            List&lt;Double&gt; res = new ArrayList&lt;&gt;();
            Queue&lt;BinaryTreeNode&gt; q = new LinkedList&lt;&gt;();
            if(root==null || root.data==-1) return res;
            q.offer(root);
            int i=0;
            while(!q.isEmpty())
            {
                int size=q.size();
                i++;
                double sum=0;
                for(int s=0;s&lt;size;s++)
                {
                    BinaryTreeNode r = q.poll();
                    sum+=r.data;
                    if(r.left!=null &amp;&amp; r.left.data!=-1) q.offer(r.left);
                    if(r.right!=null &amp;&amp; r.right.data!=-1) q.offer(r.right);
                }
                res.add(sum/size);
            }
            return res;
        }
    }
    
    public class AverageOfLevels
    {
        static BinaryTreeNode root;
        void insert(BinaryTreeNode temp, int key)
        { 
            if (temp == null) 
            {
                temp = new BinaryTreeNode(key);
                return;
            }
            Queue&lt;BinaryTreeNode&gt; q = new LinkedList&lt;BinaryTreeNode&gt;();
            q.add(temp);
     
            // Do level order traversal until we find an empty place.
            while (!q.isEmpty()) {
                temp = q.remove();
     
                if (temp.left == null) {
                    temp.left = new BinaryTreeNode(key);
                    break;
                }
                else
                    q.add(temp.left);
     
                if (temp.right == null) {
                    temp.right = new BinaryTreeNode(key);
                    break;
                }
                else
                    q.add(temp.right);
            }
        }
    
        public static void main(String args[])
        {
            Scanner sc=new Scanner(System.in);
            AverageOfLevels ln=new AverageOfLevels();
            Solution sol= new Solution();
            
            String str[]=sc.nextLine().split(&quot; &quot;);
            root=new BinaryTreeNode(Integer.parseInt(str[0]));
            for(int i=1; i&lt;str.length; i++)
                ln.insert(root,Integer.parseInt(str[i]));
    
            System.out.println(sol.averageOfLevels(root));
        }
    }
    </code></pre><h2 id="15758fd8-d211-80f0-9b78-ee76f54ac7cd" class=""><strong>Largest_Value_In_Tree_Row</strong></h2><p id="15758fd8-d211-800e-a59d-e2d687376c41" class="">For X-Mas, santa claus is preparing a X-Mas Tree with set of Bulbs.<br/>The bulbs are of different voltages, and preparation of tree as follows:<br/>- The bulbs are arranged in level-wise, levels are numbered from 0,1,2,3..<br/>so on.<br/>- At level-0: There will be only one bulb as root bulb.,<br/>- From next level onwards, we can attach atmost two bulbs to left side,<br/>and right side of every bulb in previous level.<br/>- The empty attachements in each level are indicated with -1.<br/></p><p id="15758fd8-d211-8078-99e4-d1d019f3ceca" class="">You will be given the root of the X-Mas Tree,<br/>Your task is to findout the bulb with highest voltage in each level.<br/></p><p id="15758fd8-d211-80e1-a2fb-cbb4c057372a" class="">Implement the class Solution:<br/>1.public List&lt;Integer&gt; maxInEachRow(BinaryTreeNode root): returns the list of integers.<br/></p><h2 id="15758fd8-d211-8023-a282-f59ef42b1fe0" class="">Input Format:</h2><p id="15758fd8-d211-80d1-8795-ca984eec59a1" class="">A single line of space separated integers, voltages of the set of bulbs.</p><h2 id="15758fd8-d211-804b-98f6-ef4abb6954ac" class="">Output Format:</h2><p id="15758fd8-d211-80f1-94c6-c2f8b38f42ec" class="">Print the list of voltages.</p><h2 id="15758fd8-d211-804e-9af7-ff5db2d05812" class="">Sample Input-1:</h2><p id="15758fd8-d211-8057-87fe-c249360161c8" class="">2 4 3 6 4 -1 9</p><h2 id="15758fd8-d211-80b3-87d1-f478eb84568a" class="">Sample Output-1:</h2><p id="15758fd8-d211-8009-b8c2-f3ab6f5e5361" class="">[2, 4, 9]</p><h2 id="15758fd8-d211-80e1-81d4-c369449ee1ce" class="">Sample Input-2:</h2><p id="15758fd8-d211-800d-9efb-ed5336cccd8b" class="">3 4 7 7 3 8 4</p><h2 id="15758fd8-d211-80b9-be51-f1a96979fb22" class="">Sample Output-2:</h2><p id="15758fd8-d211-8000-8903-e1076cbef132" class="">[3, 4, 8]</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="15758fd8-d211-80d7-973e-f2379e8ea8a5" class="code"><code class="language-Java">import java.util.*;
    
    class BinaryTreeNode
    {
        public int data; 
        public BinaryTreeNode left, right; 
        public BinaryTreeNode(int data)
        {
            this.data = data; 
            left = null; 
            right = null; 
        }
    }
    
    class Solution 
    {
        public List&lt;Integer&gt; largestValues(BinaryTreeNode root) 
        {
            //Write your code here and return a list
            List&lt;Integer&gt; res = new ArrayList&lt;&gt;();
            Queue&lt;BinaryTreeNode&gt; q = new LinkedList&lt;&gt;();
            if(root==null || root.data==-1) return res;
            q.offer(root);
            int i=0;
            while(!q.isEmpty())
            {
                int size=q.size();
                i++;
                int  maxi=-1;
                for(int s=0;s&lt;size;s++)
                {
                    BinaryTreeNode r = q.poll();
                    maxi=Math.max(r.data,maxi);
                    if(r.left!=null &amp;&amp; r.left.data!=-1) q.offer(r.left);
                    if(r.right!=null &amp;&amp; r.right.data!=-1) q.offer(r.right);
                }
                res.add(maxi);
            }
            return res;
        }
    
        //Your supporting methods(if any) goes here
    }
    
    public class LargestValue 
    {
        static BinaryTreeNode root;
        void insert(BinaryTreeNode temp, int key)
        { 
            if (temp == null) {
                temp = new BinaryTreeNode(key);
                return;
            }
            Queue&lt;BinaryTreeNode&gt; q = new LinkedList&lt;BinaryTreeNode&gt;();
            q.add(temp);
     
            // Do level order traversal until we find an empty place.
            while (!q.isEmpty()) 
            {
                temp = q.remove();
    
                if (temp.left == null) {
                    temp.left = new BinaryTreeNode(key);
                    break;
                }
                else
                    q.add(temp.left);
     
                if (temp.right == null) {
                    temp.right = new BinaryTreeNode(key);
                    break;
                }
                else
                    q.add(temp.right);
            }
        }
    
        public static void main(String args[])
        {
            Scanner sc=new Scanner(System.in);
            LargestValue ln=new LargestValue();
            Solution sol= new Solution();
            
            String str[]=sc.nextLine().split(&quot; &quot;);
            root=new BinaryTreeNode(Integer.parseInt(str[0]));
            for(int i=1; i&lt;str.length; i++)
                ln.insert(root,Integer.parseInt(str[i]));
    
            System.out.println(sol.largestValues(root));
        }
    }
    </code></pre><h2 id="15758fd8-d211-80c4-97d4-dd3204e5f8de" class=""><strong>Largest_Value_In_Tree_Row_DFS</strong></h2><p id="15758fd8-d211-8087-8f61-ef4eb9f65b6d" class="">For X-Mas, santa claus is preparing a X-Mas Tree with set of Bulbs.<br/>The bulbs are of different voltages, and preparation of tree as follows:<br/>- The bulbs are arranged in level-wise, levels are numbered from 0,1,2,3..<br/>so on.<br/>- At level-0: There will be only one bulb as root bulb.,<br/>- From next level onwards, we can attach atmost two bulbs to left side,<br/>and right side of every bulb in previous level.<br/>- The empty attachements in each level are indicated with -1.<br/></p><p id="15758fd8-d211-8032-90f9-df2adc55c9b1" class="">You will be given the root of the X-Mas Tree,<br/>Your task is to findout the bulb with highest voltage in each level.<br/></p><p id="15758fd8-d211-80d7-8833-fd0355601847" class="">Implement the class Solution:<br/>1.public List&lt;Integer&gt; maxInEachRow(BinaryTreeNode root): returns the list of integers.<br/></p><h2 id="15758fd8-d211-80ee-96d8-f6ea66baa967" class="">Input Format:</h2><p id="15758fd8-d211-808e-bed8-fe125314df93" class="">A single line of space separated integers, voltages of the set of bulbs.</p><h2 id="15758fd8-d211-8046-8b51-f89a61551dbe" class="">Output Format:</h2><p id="15758fd8-d211-80f4-801a-dbd508f5d821" class="">Print the list of voltages.</p><h2 id="15758fd8-d211-80cb-8366-e9b28c7749b1" class="">Sample Input-1:</h2><p id="15758fd8-d211-803c-b0ef-c4533066f266" class="">2 4 3 6 4 -1 9</p><h2 id="15758fd8-d211-809c-aba0-fe20d2f0d61b" class="">Sample Output-1:</h2><p id="15758fd8-d211-8013-a714-dc9a075f7da2" class="">[2, 4, 9]</p><h2 id="15758fd8-d211-8046-8a2b-c0aae049bfe2" class="">Sample Input-2:</h2><p id="15758fd8-d211-8040-a86f-ddf7a7c5e423" class="">3 4 7 7 3 8 4</p><h2 id="15758fd8-d211-8081-ad74-e52ca26a197c" class="">Sample Output-2:</h2><p id="15758fd8-d211-80ee-ac76-c73c063b89bb" class="">[3, 4, 8]</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="15758fd8-d211-805b-8444-eb19f5bb240f" class="code"><code class="language-Java">import java.util.*;
    
    class BinaryTreeNode
    {
        public int data; 
        public BinaryTreeNode left, right; 
        public BinaryTreeNode(int data)
        {
            this.data = data; 
            left = null; 
            right = null; 
        }
    }
    
    class Solution 
    {
        public List&lt;Integer&gt; largestValues(BinaryTreeNode root) 
        {
            //Write your code here and return a list
            List&lt;Integer&gt; lst = new ArrayList&lt;&gt;();
            dfs(lst,0,root);
            return lst;
        }
        public void dfs(List&lt;Integer&gt; lst, int level, BinaryTreeNode root) {
            if(root==null || root.data==-1) return;
            if(lst.size()==level) {
                lst.add(root.data);
            }
            else {
                if(lst.get(level) &lt; root.data) {
                    lst.set(level, root.data);
                }
            }
            dfs(lst,level+1,root.left);
            dfs(lst,level+1,root.right);
        }
        //Your supporting methods(if any) goes here
    }
    
    public class LargestValue 
    {
        static BinaryTreeNode root;
        void insert(BinaryTreeNode temp, int key)
        { 
            if (temp == null) {
                temp = new BinaryTreeNode(key);
                return;
            }
            Queue&lt;BinaryTreeNode&gt; q = new LinkedList&lt;BinaryTreeNode&gt;();
            q.add(temp);
     
            // Do level order traversal until we find an empty place.
            while (!q.isEmpty()) 
            {
                temp = q.remove();
    
                if (temp.left == null) {
                    temp.left = new BinaryTreeNode(key);
                    break;
                }
                else
                    q.add(temp.left);
     
                if (temp.right == null) {
                    temp.right = new BinaryTreeNode(key);
                    break;
                }
                else
                    q.add(temp.right);
            }
        }
    
        public static void main(String args[])
        {
            Scanner sc=new Scanner(System.in);
            LargestValue ln=new LargestValue();
            Solution sol= new Solution();
            
            String str[]=sc.nextLine().split(&quot; &quot;);
            root=new BinaryTreeNode(Integer.parseInt(str[0]));
            for(int i=1; i&lt;str.length; i++)
                ln.insert(root,Integer.parseInt(str[i]));
    
            System.out.println(sol.largestValues(root));
        }
    }
    </code></pre><h2 id="15758fd8-d211-8036-80ab-fc9301bf5c66" class=""><strong>Right_SideView_of_Tree</strong></h2><p id="15758fd8-d211-8030-ad47-c9e9fbd3307e" class="">Balbir singh is working with Binary Trees.<br/>The elements of the tree is given in the level order format.<br/>Balbir is looking the tree from right side.<br/>So, he can view only rightmost nodes only (one node per level).<br/></p><p id="15758fd8-d211-8092-b79d-e61dc36875fb" class="">You will be given the root of the binary tree.<br/>Your task is to find the nodes which can be viewed by Balbir from right side.<br/>And print the nodes from top to bottom order.<br/></p><p id="15758fd8-d211-80f5-aa52-e39bdd172e1f" class="">Your task is to implement the class Solution:<br/>- public List&lt;Integer&gt; rightSideView(BinaryTreeNode root):<br/>return the list of node values.<br/></p><p id="15758fd8-d211-809b-b7be-e912b8b7fb41" class="">NOTE:<br/>Please do consider the node with data=-1 as null node in the given trees.<br/></p><h2 id="15758fd8-d211-8061-b5c5-c71f6a0ae95b" class="">Input Format:</h2><p id="15758fd8-d211-8030-9f90-da9ea7dff099" class="">Space separated integers, elements of the tree.</p><h2 id="15758fd8-d211-8096-bbe5-f956fd0fd737" class="">Output Format:</h2><p id="15758fd8-d211-80ca-887b-c0ca75a181d5" class="">Print a boolean value.</p><h2 id="15758fd8-d211-80ca-8cf1-d76820583691" class="">Sample Input-1:</h2><p id="15758fd8-d211-8046-8712-dcda94e621cf" class="">1 2 3 5 -1 -1 5</p><h2 id="15758fd8-d211-80d8-a568-f5882adfee0a" class="">Sample Output-1:</h2><p id="15758fd8-d211-80ca-bf68-db2f5b360205" class="">[1, 3, 5]</p><h2 id="15758fd8-d211-8021-b69c-e337e825c2e2" class="">Sample Input-2:</h2><p id="15758fd8-d211-8065-9bf7-cac05b356e89" class="">3 2 4 3 2</p><h2 id="15758fd8-d211-80e3-8d5a-c99c173da03c" class="">Sample Output-2:</h2><p id="15758fd8-d211-8061-aa14-f25baa06b2e8" class="">[3, 4, 2]</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="15758fd8-d211-804d-a84b-fb826d1e031a" class="code"><code class="language-Java">import java.util.*;
    
    class BinaryTreeNode
    {
        public int data; 
        public BinaryTreeNode left, right; 
        public BinaryTreeNode(int data)
        {
            this.data = data; 
            left = null; 
            right = null; 
        }
    }
    
    class Solution 
    {
        public List&lt;Integer&gt; rightSideView(BinaryTreeNode root) 
        {
            //Write your code here and return a list
            List&lt;Integer&gt; res = new ArrayList&lt;&gt;();
            Queue&lt;BinaryTreeNode&gt; q = new LinkedList&lt;&gt;();
            if(root==null || root.data==-1) return res;
            q.offer(root);
            while(!q.isEmpty())
            {
                int size=q.size();
                double sum=0;
                for(int s=0;s&lt;size;s++)
                {
                    BinaryTreeNode r = q.poll();
                    if(s==size-1) res.add(r.data);
                    if(r.left!=null &amp;&amp; r.left.data!=-1) q.offer(r.left);
                    if(r.right!=null &amp;&amp; r.right.data!=-1) q.offer(r.right);
                }
                
            }
            return res;
        }
        
        //Your supporting methods(if any) goes here
    }
    
    public class RightSideView 
    {
        static BinaryTreeNode root;
        static BinaryTreeNode temp = root;
        void insert(BinaryTreeNode temp, int key)
        { 
            if (temp == null) {
                root = new BinaryTreeNode(key);
                return;
            }
            Queue&lt;BinaryTreeNode&gt; q = new LinkedList&lt;BinaryTreeNode&gt;();
            q.add(temp);
     
            // Do level order traversal until we find an empty place.
            while (!q.isEmpty()) 
            {
                temp = q.remove();
    
                if (temp.left == null) 
                {
                    temp.left = new BinaryTreeNode(key);
                    break;
                }
                else
                    q.add(temp.left);
     
                if (temp.right == null) {
                    temp.right = new BinaryTreeNode(key);
                    break;
                }
                else
                    q.add(temp.right);
            }
        }
        
        public static void main(String args[])
        {
            Scanner sc=new Scanner(System.in);
            String str[]=sc.nextLine().split(&quot; &quot;);
            RightSideView bt=new RightSideView();
            root=new BinaryTreeNode(Integer.parseInt(str[0]));
    
            for(int i=1; i&lt;str.length; i++)
                bt.insert(root,Integer.parseInt(str[i]));
    
            Solution sol= new Solution();
            System.out.println(sol.rightSideView(root));
        }
    }</code></pre><h2 id="15758fd8-d211-80c9-aa9a-d4f3e5172b81" class=""><strong>LCA</strong></h2><p id="15758fd8-d211-80af-af9d-eb49e5a4180a" class="">You are given a binary tree with unique values for its nodes and two distinct nodes p and q.<br/>Your task is to find the Lowest Common Ancestor (LCA) of these two nodes.<br/></p><p id="15758fd8-d211-80cb-84b1-f08d4b3be857" class="">The Lowest Common Ancestor is defined as the deepest node in the binary tree<br/>that has both p and q as descendants (where a node can be a descendant of itself).<br/></p><h2 id="15758fd8-d211-8079-9575-e456470806c1" class="">Input Format:</h2><p id="15758fd8-d211-804a-881c-ffb24f83c107" class="">Line-1: A list of integers (space-separated) representing the binary tree in level order traversal.<br/>Line-2: Two integers p and q, representing the values of the two nodes for which the LCA is to be determined.<br/></p><p id="15758fd8-d211-8025-a445-e3b1b75fcb71" class="">NOTE: Use -1 for null nodes.</p><h2 id="15758fd8-d211-80bd-ad17-f76f4fd008d3" class="">Output Format:</h2><p id="15758fd8-d211-80e1-a644-f7e67bc408ae" class="">Line-1: Print the value of the Lowest Common Ancestor.</p><h2 id="15758fd8-d211-80a3-b640-c455bb224c89" class="">Sample Input-1:</h2><p id="15758fd8-d211-8083-8c6b-edc805be86d4" class="">3 5 1 6 2 0 8 -1 -1 7 4<br/>5 1<br/></p><h2 id="15758fd8-d211-809d-9b88-f88a49bc711e" class="">Sample Output-1:</h2><p id="15758fd8-d211-80ff-b7b4-c830d28bf120" class="">3</p><h2 id="15758fd8-d211-80e5-8b9f-db0d21829c51" class="">Sample Input-2:</h2><p id="15758fd8-d211-806a-9ff6-c643f7c207b3" class="">3 5 1 6 2 0 8 -1 -1 7 4<br/>5 4<br/></p><h2 id="15758fd8-d211-801f-aa9c-c8ea6881634b" class="">Sample Output-2:</h2><p id="15758fd8-d211-80b2-94cf-e385abe2a0ed" class="">5</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="15758fd8-d211-8058-8614-cf58bf44d2cd" class="code"><code class="language-Java">import java.util.*;
    
    class BinaryTreeNode {
        public int data;
        public BinaryTreeNode left, right;
    
        public BinaryTreeNode(int data) {
            this.data = data;
            left = null;
            right = null;
        }
    }
    
    class Solution {
        public BinaryTreeNode lowestCommonAncestor(BinaryTreeNode root, BinaryTreeNode p, BinaryTreeNode q) {
            //Write your code here
            if(root==null || root.data==-1) return null;
            if(root==p) return root;
            if(root==q) return root;
            BinaryTreeNode leftFound = lowestCommonAncestor(root.left,p,q);
            BinaryTreeNode rightFound = lowestCommonAncestor(root.right,p,q);
            if(leftFound!=null &amp;&amp; rightFound!=null) return root;
            if(leftFound==null &amp;&amp; rightFound==null) return null;
            if(leftFound!=null) return leftFound;
            return rightFound;
        }
        
        public BinaryTreeNode findNode(BinaryTreeNode root, int val) {
            if(root==null || root.data==-1) return null;
            if(root.data==val) return root;
            BinaryTreeNode lft = findNode(root.left,val);
            BinaryTreeNode rgt = findNode(root.right,val);
            if(lft!=null) return lft;
            return rgt;
        }
    
    
        //Your supporting methods(if any) goes here
    }
    
    public class LCA {
        static BinaryTreeNode root;
    
        void insert(BinaryTreeNode temp, int key) {
            if (temp == null) {
                root = new BinaryTreeNode(key);
                return;
            }
            Queue&lt;BinaryTreeNode&gt; q = new LinkedList&lt;&gt;();
            q.add(temp);
    
            // Do level order traversal until we find an empty place
            while (!q.isEmpty()) {
                temp = q.poll();
    
                if (temp.left == null) {
                    temp.left = new BinaryTreeNode(key);
                    break;
                } else
                    q.add(temp.left);
    
                if (temp.right == null) {
                    temp.right = new BinaryTreeNode(key);
                    break;
                } else
                    q.add(temp.right);
            }
        }
    
        public static void main(String[] args) {
            Scanner sc = new Scanner(System.in);
            String str[] = sc.nextLine().split(&quot; &quot;);
            LCA lca = new LCA();
            root = new BinaryTreeNode(Integer.parseInt(str[0]));
            for (int i = 1; i &lt; str.length; i++) {
                lca.insert(root, Integer.parseInt(str[i]));
            }
    
            int pValue = sc.nextInt();
            int qValue = sc.nextInt();
    
            Solution sol = new Solution();
    
            // Retrieve actual nodes for p and q
            BinaryTreeNode p = sol.findNode(root, pValue);
            BinaryTreeNode q = sol.findNode(root, qValue);
    
            if (p == null || q == null) {
                System.out.println(&quot;One or both nodes not found in the tree&quot;);
            } else {
                BinaryTreeNode res = sol.lowestCommonAncestor(root, p, q);
                System.out.println(res.data);
            }
        }
    }
    </code></pre><h2 id="15758fd8-d211-80e0-b57d-ce73a70c7cb9" class="">Great_Nodes</h2><p id="15758fd8-d211-80e0-9b57-ef5ba6d86e52" class="">Given a binary tree root, a node X in the tree is named Great if in the path<br/>from root to X there are no nodes with a value greater than or equals X.<br/></p><p id="15758fd8-d211-8031-ad0c-d55a90cc4771" class="">Return the number of Great nodes in the binary tree.</p><p id="15758fd8-d211-8009-a5ee-cef12ae6d96d" class="">You will be given root node of a binary tree return total number of nodes which satisfies above statement.</p><h2 id="15758fd8-d211-80c2-964b-d5f7b054d3ed" class="">Input format:</h2><p id="15758fd8-d211-805f-adfb-d41241dc72a9" class="">Line-1: Space seperated integers</p><h2 id="15758fd8-d211-80f0-b659-c209ffa81a29" class="">Output format:</h2><p id="15758fd8-d211-805b-9eaa-cfa66d0d575d" class="">Line-1: An integer</p><h2 id="15758fd8-d211-80ff-b766-ffe3811a521c" class="">Sample Input-1:</h2><p id="15758fd8-d211-80fc-b768-f8518b08b3ad" class="">3 1 4 3 -1 1 5</p><h2 id="15758fd8-d211-80e9-a24f-f32b0520f247" class="">Sample Output-1:</h2><p id="15758fd8-d211-80a4-8114-ca16d56df6dd" class="">4</p><p id="15758fd8-d211-809e-a473-c256c536c830" class="">Explanation:<br/>Root Node (3) is always a Great node.<br/>Node 4 -&gt; (3,4) is the maximum value in the path starting from the root.<br/>Node 5 -&gt; (3,4,5) is the maximum value in the path<br/>Node 3 -&gt; (3,1,3) is the maximum value in the path.<br/></p><h2 id="15758fd8-d211-80bc-883e-e839d950041f" class="">Sample Input-2:</h2><p id="15758fd8-d211-80c0-ab9f-d7e9b23f9fe5" class="">3 5 1 6 2 9 8 -1 -1 7 4</p><h2 id="15758fd8-d211-8000-b173-e3c60815b2b0" class="">Sample Output-2:</h2><p id="15758fd8-d211-800d-82e5-eb54ea41e7a0" class="">6</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="15758fd8-d211-8061-ba75-f538db49e778" class="code"><code class="language-Java">import java.util.*;
    
    class BinaryTreeNode 
    {
        public Integer data;
        public BinaryTreeNode left, right;
        public BinaryTreeNode(Integer data) 
        {
            this.data = data;
            this.left = this.right = null;
        }
    }
    
    class Solution {
        public int greatNodes(BinaryTreeNode root) {
            //Write your code here
            int[] cnt = new int[1];
            dfs(root,root.data,cnt);
            return cnt[0];
        }
    
        //Your supporting methods(if any) goes here
        public void dfs(BinaryTreeNode root, int currHighest, int[] cnt){
            if(root == null || root.data==-1) return;
            if(root.data &gt;= currHighest) {
                currHighest = root.data;
                cnt[0]++;
            }
            dfs(root.left,currHighest,cnt);
            dfs(root.right,currHighest,cnt);
        }
    }
    
    class BTree {
        static BinaryTreeNode root;
    
        void insert(BinaryTreeNode temp, Integer key) {
            if (temp == null) {
                root = new BinaryTreeNode(key);
                return;
            }
            Queue&lt;BinaryTreeNode&gt; q = new LinkedList&lt;&gt;();
            q.add(temp);
            while (!q.isEmpty()) {
                temp = q.poll();
                if (temp.left == null) {
                    if (key != null &amp;&amp; key != -1) {
                        temp.left = new BinaryTreeNode(key);
                    }
                    break;
                } else {
                    q.add(temp.left);
                }
                if (temp.right == null) {
                    if (key != null &amp;&amp; key != -1) {
                        temp.right = new BinaryTreeNode(key);
                    }
                    break;
                } else {
                    q.add(temp.right);
                }
            }
        }
    
        public static void main(String args[]) {
            Scanner sc = new Scanner(System.in);
            String[] str = sc.nextLine().split(&quot; &quot;);
            BTree tree = new BTree();
            BinaryTreeNode root1 = new BinaryTreeNode(Integer.parseInt(str[0]));
            for (int i = 1; i &lt; str.length; i++) 
                tree.insert(root1, Integer.parseInt(str[i]));
            Solution sol = new Solution();
            System.out.println(sol.greatNodes(root1));
        }
    }
    </code></pre><h2 id="15758fd8-d211-803c-a184-ef820a4897c5" class=""><strong>N_Queens</strong></h2><p id="15758fd8-d211-802d-9ecc-ef92a5eacdae" class="">Akbar used to play chess with Birbal almost every evening.<br/>Once Akbar has challanged Birbal to place the queens in each row of the board,<br/>such that no queen should attack another queen on the board.<br/></p><p id="15758fd8-d211-80f7-b598-ee9c18243ecc" class="">You are given an integer N, indicates the size of the board as N*N.<br/>Your task is to help Birbal to find and win in this challange,<br/>if there is a solution, print the answer as shown in the samples<br/>Otherwise, print &quot;No Solution&quot;<br/></p><h2 id="15758fd8-d211-80a9-9a70-e0534640138f" class="">Input Format:</h2><p id="15758fd8-d211-8037-a67b-e051cfc4e475" class="">An integer N, size of the chess board.</p><h2 id="15758fd8-d211-8008-976a-df0731cebcf2" class="">Output Format:</h2><p id="15758fd8-d211-8083-8f30-f921c955547c" class="">Print any possible solution.</p><h2 id="15758fd8-d211-8064-b3f9-fd5369d17a67" class="">Sample Input-1:</h2><p id="15758fd8-d211-8087-8a29-dfcd926f1548" class="">4</p><h2 id="15758fd8-d211-8056-92e8-e42fc38841d6" class="">Sample Output-1:</h2><p id="15758fd8-d211-804f-bfee-e80e2ed076b2" class="">0010<br/>1000<br/>0001<br/>0100<br/></p><h2 id="15758fd8-d211-8023-b190-cd65bdb33309" class="">Sample Input-2:</h2><p id="15758fd8-d211-8060-a5cd-cc794d782e93" class="">3</p><h2 id="15758fd8-d211-80c4-95a1-f96c848b9dcb" class="">Sample Output-2:</h2><p id="15758fd8-d211-809a-af7b-f99f266b22c0" class="">No Solution</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="15758fd8-d211-8010-b920-ff9ed558189e" class="code"><code class="language-Java">import java.util.*;
    
    public class NQueenProblem {
        int N;
    
        /* A utility function to print solution */
        void printSolution(int board[][])
        {
            for (int i = 0; i &lt; N; i++) {
                for (int j = 0; j &lt; N; j++)
                    System.out.print(board[i][j]);
                System.out.println();
            }
        }
        
        //Your utility functions goes here
        boolean isSafe(int board[][], int row, int col)
        {
            int i, j;
    
            for (i = 0; i &lt; col; i++)
                if (board[row][i] == 1)
                    return false;
    
            for (i = row, j = col; i &gt;= 0 &amp;&amp; j &gt;= 0; i--, j--)
                if (board[i][j] == 1)
                    return false;
    
            for (i = row, j = col; j &gt;= 0 &amp;&amp; i &lt; N; i++, j--)
                if (board[i][j] == 1)
                    return false;
    
            return true;
        }
        
        boolean solve(int board[][], int col){
            if(col&gt;=N) return true;
            for(int i=0;i&lt;N;i++)
            {
                if (isSafe(board, i, col)) {
                    board[i][col] = 1;
    
                    if (solve(board, col + 1) == true)
                        return true;
    
                    board[i][col] = 0; 
                }
            }
            return false;
        }
        
        boolean solveNQ(){
            //Write your code here and return boolean value
            int[][] board = new int[N][N];
            if(solve(board,0)==false)
            {
                System.out.println(&quot;No Solution&quot;);
                return false;
            }
            printSolution(board);
            return true;
            
        }
    
        public static void main(String args[])
        {
            Scanner sc=new Scanner(System.in);
            NQueenProblem Queen = new NQueenProblem();
            Queen.N=sc.nextInt();
            Queen.solveNQ();
        }
    }</code></pre><h2 id="15758fd8-d211-80a3-9c0f-c0eea3ec3233" class=""><strong>Path_with_Max_Gold</strong></h2><p id="15758fd8-d211-806e-8957-f30fcb4e6d91" class="">The Kolar Gold Fields (KGF) is in the form of a m*n grid,<br/>Each field, contains some amount of Gold in it.<br/></p><p id="15758fd8-d211-80bf-8716-fab2e02ad3bf" class="">You can mine the gold in the KGF in the following way.<br/>- You can start at any position in the grid, never visit a cell with no gold.<br/>- each time you visit a cell, you will grab all the gold in it.<br/>- You can move one step to the left, right, up or down.<br/>- You can&#x27;t visit the same cell more than once.<br/>- You can stop at any cell.<br/></p><p id="15758fd8-d211-80e5-8ced-d3bc128e943e" class="">Your task is to find the maximum amount of gold you can collect.</p><h2 id="15758fd8-d211-809b-bf5f-e984f50ce25d" class="">Input Format:</h2><p id="15758fd8-d211-80e4-8a05-ce60965e6ed9" class="">Line-1: Two integers M and N size of the KGF grid.<br/>Next M lines: N space separated integers, gold in each row of the grid.<br/></p><h2 id="15758fd8-d211-8045-976f-c806ae279b95" class="">Output Format:</h2><p id="15758fd8-d211-80b6-933d-e6b0b4f8d460" class="">Print an integer, maximum amount of gold.</p><h2 id="15758fd8-d211-802a-8dc4-da002e73d146" class="">Sample Input-1:</h2><p id="15758fd8-d211-801d-b7ce-c5d4c1bc04be" class="">3 3<br/>3 6 0<br/>5 8 7<br/>0 9 0<br/></p><h2 id="15758fd8-d211-80ec-ad00-c5aef984efc0" class="">Sample Output-1:</h2><p id="15758fd8-d211-80dd-af3d-fda1064f4690" class="">24</p><h2 id="15758fd8-d211-806d-8379-f3ebfdd7dcce" class="">Explanation:</h2><p id="15758fd8-d211-8001-a033-c112eb87e672" class="">You can grab the gold in KGF grid as follows:<br/>You can obtain like as follows: 9 -&gt; 8 -&gt; 7.<br/></p><h2 id="15758fd8-d211-8048-bb23-d9d172aef7ab" class="">Sample Input-2:</h2><p id="15758fd8-d211-8032-8c56-d64b758c3db5" class="">5 3<br/>1 0 7<br/>2 0 6<br/>3 4 5<br/>0 3 0<br/>9 0 20<br/></p><h2 id="15758fd8-d211-803d-813f-dc0cd0389b66" class="">Sample Output-2:</h2><p id="15758fd8-d211-8099-a5c2-e5ef5410083a" class="">28</p><h2 id="15758fd8-d211-80ed-81db-c997662f2ca4" class="">Explanation:</h2><p id="15758fd8-d211-8005-8160-f79cab2eb69d" class="">You can grab the gold in KGF grid as follows:<br/>You can obtain like as follows: 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6 -&gt; 7<br/></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="15758fd8-d211-80ab-b0a7-d7f79516ccde" class="code"><code class="language-Java">import java.util.Scanner;
    
    public class GetMaximumGold {
    
    
        static int collectGold(int[][] grid, int row, int col) {
            
            if (row &lt; 0 || col &lt; 0 || row &gt;= grid.length || col &gt;= grid[0].length || grid[row][col] == 0) {
                return 0;
            }
    
            
            int gold = grid[row][col];
            grid[row][col] = 0; 
    
            int up = collectGold(grid, row - 1, col);   
            int down = collectGold(grid, row + 1, col); 
            int left = collectGold(grid, row, col - 1); 
            int right = collectGold(grid, row, col + 1);
    
            grid[row][col] = gold;
    
           
            return gold + Math.max(Math.max(up, down), Math.max(left, right));
        }
    
    
        static int findMaxGold(int[][] grid) {
            int maxGold = 0;
    
            for (int i = 0; i &lt; grid.length; i++) {
                for (int j = 0; j &lt; grid[0].length; j++) {
                    if (grid[i][j] &gt; 0) {
                        maxGold = Math.max(maxGold, collectGold(grid, i, j));
                    }
                }
            }
    
            return maxGold;
        }
    
        public static void main(String[] args) {
            Scanner sc = new Scanner(System.in);
    
    
            int m = sc.nextInt();
            int n = sc.nextInt();
    
            int[][] grid = new int[m][n];
            for (int i = 0; i &lt; m; i++) {
                for (int j = 0; j &lt; n; j++) {
                    grid[i][j] = sc.nextInt();
                }
            }
    
            System.out.println(findMaxGold(grid));
        }
    }
    </code></pre><h2 id="15758fd8-d211-80d0-9f8f-e7a8d811fbd6" class=""><strong>Campus_Bikes_II</strong></h2><p id="15758fd8-d211-80a3-99e6-e38a46490375" class="">Mr. Revanth Reddy, Chief Minister of Telangana Government has passed a new G.O to Telangana police for safety of Telangana people.<br/>In this regard he announced new Vehicles to be released for all the stations working for this mission especially.<br/>Here we have a 2D mesh, there are P police officers and V vehicles, with P&lt;=V.<br/>Each police officer and vehicle is a 2D coordinate on this mesh.<br/>Here the government has assigned a unique vehicle to each police officer.<br/></p><p id="15758fd8-d211-807f-b90e-f833f3dcc47b" class="">Now create a method which prints the minimum possible sum of distances between each police officer and their assigned vehicle.</p><p id="15758fd8-d211-801f-8b69-fb7c1c70b883" class="">Here the distance is between police officer Pi and vehicle Vi assigned to him.<br/>And distance between Pi, Vi is calculated as follows: |Pi.x - Vi.x| + |Pi.y - Vi.y|<br/></p><h2 id="15758fd8-d211-80fb-81c9-e85f47ab7d41" class="">Input Format:</h2><p id="15758fd8-d211-80ac-8468-ff5f94194bf5" class="">Line-1: Two integers P and V, number of police officers and vehicles.<br/>Next P lines: Two space separated integers co-ordinates of Police officers.<br/>Next V lines: Two space separated integers co-ordinates of Vehicles.<br/></p><h2 id="15758fd8-d211-80c4-8e57-c436569d006e" class="">Output Format:</h2><p id="15758fd8-d211-808d-b464-c88ada078cfd" class="">Print an integer, the minimum possible sum of distances.</p><h2 id="15758fd8-d211-8003-b59d-e4d39cc3624c" class="">Sample Input-1:</h2><p id="15758fd8-d211-805d-bfca-e89727988ee4" class="">3 3<br/>0 1		// co-ordinates of police<br/>1 2<br/>1 3<br/>4 5		// co-ordinates of vehicles<br/>2 5<br/>3 6<br/></p><h2 id="15758fd8-d211-8066-86f5-e8fe078f17f8" class="">Sample Output-1:</h2><p id="15758fd8-d211-8036-bb55-e37372eeb293" class="">17</p><h2 id="15758fd8-d211-8051-9280-fe75708c203c" class="">Sample Input-2:</h2><p id="15758fd8-d211-80f9-8568-f1d21a511f48" class="">2 2<br/>0 0		// co-ordinates of police<br/>2 1<br/>1 2		// co-ordinates of vehicles<br/>3 3<br/></p><h2 id="15758fd8-d211-80e8-a124-d523f4fcd152" class="">Sample Output-2:</h2><p id="15758fd8-d211-806d-b0f1-c3fb56645a17" class="">6</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="15758fd8-d211-8022-9219-d0e7692cacfd" class="code"><code class="language-Java">import java.util.*;
    
    class CampusBikes{
        public int assignBikes(int[][] workers, int[][] bikes) {
            //Write your code here and return an integer
            return findMinDist(workers,bikes);
        }
        static int min = Integer.MAX_VALUE;
        public static int calcdist(int i, int j, int[][] off, int[][] bikes) {
            return Math.abs(off[i][0]-bikes[j][0]) + Math.abs(off[i][1]-bikes[j][1]);
        }
        public static void findMinDistUtil(int[] vis, int i, int[][] off, int[][]bikes, int dist) {
            if(i==off.length &amp;&amp; dist &lt; min) {
                min = dist;
            }
            if(i&gt;=off.length) {
                return;
            }
            if(dist &gt; min) {
                return;
            }
    
            for(int j=0; j&lt;bikes.length; j++) {
                if(vis[j]==1) continue;
                vis[j] = 1;
                findMinDistUtil(vis,i+1,off,bikes,dist+calcdist(i,j,off,bikes));
                vis[j] = 0;
            } 
        }
        public static int findMinDist(int[][] off, int[][] bikes) {
            int[] vis = new int[bikes.length];
            findMinDistUtil(vis,0,off,bikes,0);
            return min;
        }
        
        //Your utility functions goes here
        
        public static void main(String[] args) { 
            Scanner sc=new Scanner(System.in);
            int m=sc.nextInt();
            int n=sc.nextInt();
            int bikes[][]=new int[n][2];
            int men[][]=new int[m][2];
            for(int i=0;i&lt;m;i++){
                men[i][0]=sc.nextInt();
                men[i][1]=sc.nextInt();
            }
            for(int i=0;i&lt;n;i++){
                bikes[i][0]=sc.nextInt();
                bikes[i][1]=sc.nextInt();
            }
            System.out.println(new CampusBikes().assignBikes(men,bikes)); 
        }
    }</code></pre><h2 id="15758fd8-d211-8057-9c60-c9102757ed52" class=""><strong>Hamiltonian_Cycle</strong></h2><p id="15758fd8-d211-80fc-9f0e-cb56f0a92783" class="">N cities are connected through roads, the cities are numbered from 0 to N-1.<br/>The roadmaps are given as a grid of size N*N, roadmap[][],<br/>the grid contains 0 and 1 as values grid[i][j]=0, indicates no road<br/>between i to j cities, grid[i][j]=1, indicates a road between i and j cities.<br/></p><p id="15758fd8-d211-80dd-b8d3-ffbbe2d673c0" class="">You are given an integer N, and the roadmap[][]of size N*N.<br/>Your task is to find that there exists a loop in the roadmap, such that<br/>there exists a route consists of all the cities eaxctly once and the<br/>last city in the route should be connected to first city of the same route directly.<br/></p><p id="15758fd8-d211-8026-9959-ff4f8eb09ae9" class="">If you found such route print the route, otherwise print &quot;No Solution&quot;</p><h2 id="15758fd8-d211-803a-bd48-e6a272baa966" class="">Input Format:</h2><p id="15758fd8-d211-8060-ace3-fb8bdb4a5bed" class="">Line-1: An integer N, size of the chess board.<br/>Next N lines: N space separated integers, 0 or 1.<br/></p><h2 id="15758fd8-d211-8023-9947-ddcde80399e0" class="">Output Format:</h2><p id="15758fd8-d211-804d-b53d-ca5e8c34e3a2" class="">Print any possible route or &quot;No Solution&quot;.</p><h2 id="15758fd8-d211-80a9-8518-c5fa5f91a5b4" class="">Sample Input-1:</h2><p id="15758fd8-d211-80a8-84a8-e606dd890879" class="">5<br/>0 1 0 1 0<br/>1 0 1 1 1<br/>0 1 0 0 1<br/>1 1 0 0 1<br/>0 1 1 1 0<br/></p><h2 id="15758fd8-d211-806d-8465-e35def6d628e" class="">Sample Output-1:</h2><p id="15758fd8-d211-80da-8ba3-e19944c73555" class="">0  1  2  4  3  0</p><h2 id="15758fd8-d211-803f-bb77-cd592a28c08d" class="">Sample Input-2:</h2><p id="15758fd8-d211-801e-92b9-ce81682b7cfd" class="">5<br/>0 1 0 1 0<br/>1 0 1 1 1<br/>0 1 0 0 1<br/>1 1 0 0 0<br/>0 1 1 0 0<br/></p><h2 id="15758fd8-d211-807d-97cc-cfee32e3ffa9" class="">Sample Output-2:</h2><p id="15758fd8-d211-80b2-8da7-da4349f84339" class="">No Solution</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="15758fd8-d211-80ff-b2f2-fb01f8572f73" class="code"><code class="language-Java">import java.util.*;
    
    class HamiltonianCycle {
        static int V;
    
        static boolean isSafe(int path[], int v, int[][] graph, int pos) {
            if (graph[path[pos - 1]][v] == 0) return false;
            for (int i = 0; i &lt; pos; i++) {
                if (path[i] == v) return false;
            }
            return true;
        }
    
        static boolean findHam(int[][] graph, int path[], int pos) {
            if (path.length == pos) {
                return graph[path[pos - 1]][path[0]] == 1;
            }
    
            for (int i = 1; i &lt; V; i++) {
                if (isSafe(path, i, graph, pos)) {
                    path[pos] = i;
                    if (findHam(graph, path, pos + 1)) return true;
                    path[pos] = -1;
                }
            }
            return false;
        }
    
        static void hamCycle(int graph[][]) {
            int[] path = new int[V];
            Arrays.fill(path, -1);
            path[0] = 0;
    
            if (!findHam(graph, path, 1)) {
                System.out.println(&quot;No Solution&quot;);
                return;
            }
    
            // Print the Hamiltonian Cycle
            for (int i = 0; i &lt; V; i++) {
                System.out.print(path[i] + &quot; &quot;);
            }
            System.out.print(path[0]); // Complete the cycle
        }
    
        public static void main(String args[]) {
            Scanner sc = new Scanner(System.in);
            V = sc.nextInt();
            int graph[][] = new int[V][V];
    
            for (int i = 0; i &lt; V; i++)
                for (int j = 0; j &lt; V; j++)
                    graph[i][j] = sc.nextInt();
    
            HamiltonianCycle obj = new HamiltonianCycle();
            obj.hamCycle(graph);
        }
    }
    </code></pre><h2 id="15758fd8-d211-807d-be3f-e53348c290d7" class="">Brace Expression</h2><p id="15758fd8-d211-8095-b853-d806eef87367" class="">Naresh is working on expression of words.<br/>If you give him an expression like, [p,q,r]s[t,u],<br/>Naresh will form the words like as follows : [pst, psu, qst,qsu, rst, rsu]<br/>Another example, [a,b]c[d,e] will be converted as: [acd, ace, bcd, bce].<br/></p><p id="15758fd8-d211-803d-8a2d-fcda94d3f366" class="">Naresh will be given an expression as a string EXP, like the above format.<br/>He needs to return all words that can be formed in like mentioned above,<br/>Can you help Naresh to convert iven expression into a list of words, in lexicographical order.<br/></p><p id="15758fd8-d211-807c-b5ca-fb6e1d0a1c35" class="">NOTE:<br/>Expression consist of lowercase alphabets, comma, and square brackets only.<br/></p><h2 id="15758fd8-d211-80e0-a735-dffcf8a21ffb" class="">Input Format:</h2><p id="15758fd8-d211-8036-bd69-e5cff3756130" class="">Line-1: A string EXP, expression.</p><h2 id="15758fd8-d211-80a5-957c-f5debee3bfc7" class="">Output Format:</h2><p id="15758fd8-d211-80da-b399-c1950a9c0d9b" class="">Line-1: Print list of words, formed from the expression.</p><h2 id="15758fd8-d211-8036-a14b-e3f533961047" class="">Sample Input-1:</h2><p id="15758fd8-d211-809b-9851-c2ce9ff40233" class="">[b]c[e,g]k</p><h2 id="15758fd8-d211-80cd-ae31-ee292538810e" class="">Sample Output-1:</h2><p id="15758fd8-d211-80bf-920d-ce3c99eccf5d" class="">[bcek, bcgk]</p><h2 id="15758fd8-d211-804c-9b1c-d24e0e3ede6d" class="">Sample Input-2:</h2><p id="15758fd8-d211-801f-a42f-f2d78097bc4f" class="">[a,b][c,d]</p><h2 id="15758fd8-d211-8091-af71-eb69612b1f1b" class="">Sample Output-2:</h2><p id="15758fd8-d211-803c-a6ad-d4c8dc45447d" class="">[ac, ad, bc, bd]</p><h2 id="15758fd8-d211-80bd-8502-fa5e6cbc19f1" class="">Sample Input-3:</h2><p id="15758fd8-d211-8093-8953-f914209140db" class="">[xyz]a[b,c]</p><h2 id="15758fd8-d211-8050-9104-e34c17b06240" class="">Sample Output-3:</h2><p id="15758fd8-d211-806c-a9fe-f5291465653a" class="">[xyzab, xyzac]</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="15758fd8-d211-80ab-ad2d-f363aea2a76d" class="code"><code class="language-Java">import java.util.*;
    
    class BraceExpression {
    
        static void parseString(String s, List&lt;List&lt;String&gt;&gt; l) {
            for (int i = 0; i &lt; s.length(); i++) {
                if (s.charAt(i) == &#x27;[&#x27;) {
                    int ind = s.indexOf(&#x27;]&#x27;, i);
                    if (ind == -1) {
                        return;
                    }
                    String[] t = s.substring(i + 1, ind).split(&quot;,&quot;);
                    l.add(Arrays.asList(t));
                    i = ind;
                } else {
                    l.add(Collections.singletonList(s.charAt(i) + &quot;&quot;));
                }
            }
        }
    
        static void braceExpression(int ind, List&lt;List&lt;String&gt;&gt; l, List&lt;String&gt; res, List&lt;String&gt; s) {
            if (ind == l.size()) {
                StringBuilder x = new StringBuilder();
                for (String part : s) {
                    x.append(part);
                }
                res.add(x.toString());
                return;
            }
            for (String p : l.get(ind)) {
                s.add(p);
                braceExpression(ind + 1, l, res, s);
                s.remove(s.size() - 1);
            }
        }
    
        public static void main(String[] args) {
            Scanner sc = new Scanner(System.in);
            String s = sc.next();
            List&lt;List&lt;String&gt;&gt; l = new ArrayList&lt;&gt;();
            parseString(s, l);
            List&lt;String&gt; res = new ArrayList&lt;&gt;();
            braceExpression(0, l, res, new ArrayList&lt;&gt;());
            Collections.sort(res);
            System.out.println(res);
        }
    }
    </code></pre><h2 id="15758fd8-d211-8055-933d-fcb1bdf04b93" class=""><strong>Gray_Code</strong></h2><p id="15758fd8-d211-800c-b2b1-ebd5e5ecf61d" class="">Given a integer value N, indicates number of bits in a binary number.</p><p id="15758fd8-d211-80b1-9aca-cfa404bcc4c7" class="">An n-bit gray code sequence is a sequence of 2n integers where:<br/>-Every integer is in the inclusive range [0, 2n - 1],<br/>-The first integer is 0,<br/>-An integer appears no more than once in the sequence,<br/>-The binary representation of every pair of adjacent integers differs by exactly one bit, and<br/>-The binary representation of the first and last integers differs by exactly one bit.<br/></p><p id="15758fd8-d211-8084-919d-fe14ef71d59f" class="">Given an integer n, return any valid n-bit gray code sequence.</p><h2 id="15758fd8-d211-807c-ab97-d97b9391107c" class="">Input Format:</h2><p id="15758fd8-d211-8074-a23a-d29922f84ec3" class="">Line-1: A integer N</p><h2 id="15758fd8-d211-8084-b762-e815056b3881" class="">Output Format:</h2><p id="15758fd8-d211-8056-839b-f542ea6acb85" class="">Line-1: Print the list of integer values.</p><h2 id="15758fd8-d211-807b-b10b-cbc012fb091b" class="">Sample Input-1:</h2><p id="15758fd8-d211-80c0-bd34-d155befb7eeb" class="">2</p><h2 id="15758fd8-d211-8025-8a7b-c138c04949c2" class="">Sample Output-1:</h2><p id="15758fd8-d211-80f9-a39a-f65cd1f1f267" class="">[0, 1, 3, 2]</p><h2 id="15758fd8-d211-8052-9c66-de23a77dc54b" class="">Explanation:</h2><p id="15758fd8-d211-8083-8e9d-c9588041600b" class="">00 - 0<br/>01 - 1<br/>11 - 3<br/>10 - 2<br/></p><h2 id="15758fd8-d211-8095-b137-cfdc1830d3a7" class="">Sample Input-2:</h2><p id="15758fd8-d211-8034-b7bd-edb6dc580279" class="">3</p><h2 id="15758fd8-d211-803a-ab73-de9ec1b5c0c7" class="">Sample Output-2:</h2><p id="15758fd8-d211-8062-95aa-d91f5ad1f324" class="">[0, 1, 3, 2, 6, 7, 5, 4]</p><h2 id="15758fd8-d211-808a-9895-d57fa7ddcef6" class="">Explanation:</h2><p id="15758fd8-d211-80c8-b273-c69ddda7b71b" class="">000 - 0<br/>001 - 1<br/>011 - 3<br/>010 - 2<br/>110 - 6<br/>111 - 7<br/>101 - 5<br/>100 - 4<br/></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="15758fd8-d211-80e9-9808-c6eaf2469812" class="code"><code class="language-Java">import java.util.*;
    class GrayCode{
        
        static void findGrayCodes(List&lt;Integer&gt; res,int n)
        {
            if(res.size()==1&lt;&lt;n) return;
            int ele = res.get(res.size()-1);
            for(int i=0;i&lt;n;i++){
                int next = ele^(1&lt;&lt;i);
                if(!res.contains(next))
                {
                    res.add(next);
                    findGrayCodes(res,n);
                }
            }
        }
        static List&lt;Integer&gt; grayCode(int n)
        {
            List&lt;Integer&gt; res = new ArrayList&lt;&gt;();
            res.add(0);
            findGrayCodes(res,n);
            return res;
        }
        public static void main(String[] args){
            Scanner sc = new Scanner(System.in);
            int n=sc.nextInt();
            System.out.println(grayCode(n));
        }
    }</code></pre><h2 id="15758fd8-d211-8064-b28b-e606dd17cc83" class=""><strong>Additive_Number</strong></h2><p id="15758fd8-d211-8057-9731-f0c555713653" class="">An additive number is a string whose digits can form an additive sequence.</p><p id="15758fd8-d211-8020-8630-f1686865ded3" class="">A valid additive sequence should contain at least three numbers.<br/>Except for the first two numbers, each subsequent number in the sequence must be the sum of the preceding two.<br/></p><p id="15758fd8-d211-80c2-a736-ee4d3f66dded" class="">Given a string containing only digits, return true if it is an additive number or false otherwise.</p><p id="15758fd8-d211-8047-9bf9-ce956870f835" class="">Note: Numbers in the additive sequence cannot have leading zeros, so sequence 1, 2, 03 or 1, 02, 3 is invalid.</p><h2 id="15758fd8-d211-808c-a5c5-f05ed9282a18" class="">Input Format:</h2><p id="15758fd8-d211-8084-8efc-c251abd58bb3" class="">Line-1: An integer</p><h2 id="15758fd8-d211-80a3-b22b-f818883fd91d" class="">Output Format:</h2><h2 id="15758fd8-d211-80d0-8985-e7a9f79d43ce" class="">Line-1: A boolean value<br/>Sample Input-1:<br/></h2><p id="15758fd8-d211-8011-af95-e79a224160d3" class="">112358</p><h2 id="15758fd8-d211-80d6-b2d7-d0fb29879ca6" class="">Sample Output-1:</h2><p id="15758fd8-d211-8053-80e0-c443d71f4ed4" class="">true</p><p id="15758fd8-d211-8037-b2ae-dcbfd504865a" class="">Explanation:<br/>The digits can form an additive sequence: 1, 1, 2, 3, 5, 8.<br/>1 + 1 = 2, 1 + 2 = 3, 2 + 3 = 5, 3 + 5 = 8<br/></p><h2 id="15758fd8-d211-802a-ad72-dd1fa731c787" class="">Sample Input-2:</h2><p id="15758fd8-d211-8061-a32d-f07c76a32ab4" class="">199100199</p><h2 id="15758fd8-d211-809a-883f-d643a3d15117" class="">Sample Output-2:</h2><p id="15758fd8-d211-8089-835d-c5b5de683b68" class="">true</p><p id="15758fd8-d211-803a-8c6d-c4fcfd1dd89a" class="">Explanation:<br/>The additive sequence is: 1, 99, 100, 199.<br/>1 + 99 = 100, 99 + 100 = 199<br/></p><h2 id="15758fd8-d211-8049-b014-f53b16bb6a04" class="">Sample Input-3:</h2><p id="15758fd8-d211-80b7-8ea5-c3575de851f4" class="">789</p><h2 id="15758fd8-d211-808b-a5c8-c3781a4d42a8" class="">Sample Output-3:</h2><p id="15758fd8-d211-80fd-be8a-f238592bc391" class="">false</p><h2 id="15758fd8-d211-8096-852a-fb38e9e99146" class="">Constraints:</h2><p id="15758fd8-d211-80b8-b08e-d7a843cb045c" class="">1 &lt;= num.length &lt;= 35, num consists only of digits<br/>Time complexity: O(N^2)<br/>Space complexity: O(1)<br/></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="15758fd8-d211-802c-972c-ed4eea11f2ea" class="code"><code class="language-Java">import java.util.*;
    
    class Solution {
    
        static boolean isAdditive(String s, int start, long num1, long num2) {
            if (start == s.length()) return true;
    
            long sum = num1 + num2;
            String sumStr = Long.toString(sum);
    
            if (!s.startsWith(sumStr, start)) return false;
    
            return isAdditive(s, start + sumStr.length(), num2, sum);
        }
    
        static boolean checkAdditive(String s) {
            int n = s.length();
    
            for (int i = 1; i &lt;= n / 2; i++) {
    
                long num1 = Long.parseLong(s.substring(0, i));
    
                for (int j = i + 1; j &lt; n; j++) {
    
                    long num2 = Long.parseLong(s.substring(i, j));
    
                    if (isAdditive(s, j, num1, num2)) {
                        return true;
                    }
                }
            }
            return false;
        }
    
        public static void main(String[] args) {
            Scanner sc = new Scanner(System.in);
            String s = sc.next();
            System.out.println(checkAdditive(s));
        }
    }
    </code></pre><h2 id="15758fd8-d211-803b-a525-e46d8bf44579" class=""><strong>Beautiful_Arrangement</strong></h2><p id="15758fd8-d211-8064-860f-dd86049faf98" class="">Ganesh is working on numbers,<br/>He is given a list of integers 1,2,3,...,N, the list is indexed from 1 to N.<br/></p><p id="15758fd8-d211-806a-859c-d146488f4fb4" class="">Now he can shuffle the list in whatever way he want.<br/>Shuffled list is said to be valid, if one of the following is true for i-th position in the list.<br/>- The integer at the i-th position is divisible by i.<br/>- &#x27;i&#x27; is divisible by the integer at the i-th position.<br/></p><p id="15758fd8-d211-8089-a751-fc435fc46a0a" class="">Now your task is to find out, How many valid shuffles can Ganesh do?</p><h2 id="15758fd8-d211-8085-8e97-fc1b4df291d7" class="">Input Format:</h2><p id="15758fd8-d211-801f-afc5-c39a5d8a5a13" class="">Line-1: An integer N, where N&lt;=20.</p><h2 id="15758fd8-d211-803c-9d80-ee38a0364133" class="">Output Format:</h2><p id="15758fd8-d211-8080-8af0-f88e9d0609f5" class="">Line-1: Print an integer, number of ways ganesh can shuffle.</p><h2 id="15758fd8-d211-802f-af88-ffb35f377dbb" class="">Sample Input:</h2><p id="15758fd8-d211-802d-a1c2-c2c846e5f6e5" class="">2</p><h2 id="15758fd8-d211-80ca-a1a6-f8565c97ec8c" class="">Sample Output:</h2><p id="15758fd8-d211-80d7-a009-fa9e60292aa4" class="">2</p><h2 id="15758fd8-d211-80bc-8b27-ddb4cc3bc70b" class="">Explanation:</h2><p id="15758fd8-d211-8042-b77a-ca0aa9644d80" class="">The first shuffled list is [1, 2]:<br/>Integer at the 1st position (i=1) is 1, and 1 is divisible by i (i=1).<br/>Integer at the 2nd position (i=2) is 2, and 2 is divisible by i (i=2).<br/></p><p id="15758fd8-d211-80fe-9ff4-c897b8666fc6" class="">The second shuffled list is [2, 1]:<br/>Integer at the 1st position (i=1) is 2, and 2 is divisible by i (i=1).<br/>Integer at the 2nd position (i=2) is 1, and i (i=2) is divisible by 1.<br/></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="15758fd8-d211-806b-adc7-dbf0a9f84e4d" class="code"><code class="language-Java">import java.util.*;
    
    class Solution {
        
        static void find(List&lt;Integer&gt; l, List&lt;Integer&gt; temp, boolean[] used, int[] count) {
            if (temp.size() == l.size()) {
                count[0]++;
                return;
            }
    
            for (int i = 0; i &lt; l.size(); i++) {
                int num = l.get(i);
                int index = temp.size() + 1;
                if (!used[i] &amp;&amp; (num % index == 0 || index % num == 0)) {
                    used[i] = true;
                    temp.add(num);
                    find(l, temp, used, count);
                    temp.remove(temp.size() - 1);
                    used[i] = false;
                }
            }
        }
    
        static void solve(List&lt;Integer&gt; l) {
            int[] count = {0};
            boolean[] used = new boolean[l.size()];
            find(l, new ArrayList&lt;&gt;(), used, count);
            System.out.println(count[0]);
        }
    
        public static void main(String[] args) {
            Scanner sc = new Scanner(System.in);
            int n = sc.nextInt();
            List&lt;Integer&gt; l = new ArrayList&lt;&gt;();
            for (int i = 1; i &lt;= n; i++) {
                l.add(i);
            }
            solve(l);
        }
    }
    </code></pre><h2 id="15758fd8-d211-800a-b280-d59985ce8474" class=""><strong>Generalized_Abbreviation</strong></h2><p id="15758fd8-d211-8009-843e-f1c0803980c7" class="">With the growing trend of shorthand writing,<br/>people often replace parts of a word with their lengths to create short-forms.<br/>A valid short-form can be created by replacing non-overlapping and non-adjacent substrings with their respective lengths.<br/></p><p id="15758fd8-d211-8035-a675-edb2f4a70287" class="">You are given a word as input.<br/>Your task is to generate all possible short-forms of the given word and return them in lexicographical order.<br/></p><h2 id="15758fd8-d211-803d-8a33-e1f475d0e309" class="">Input Format:</h2><p id="15758fd8-d211-8054-8ebb-f98b3659a8b4" class="">Line-1: A single string W representing the word.</p><h2 id="15758fd8-d211-80a6-9c6a-dc84f0474ec6" class="">Output Format:</h2><p id="15758fd8-d211-8056-942d-eb46d0efae5a" class="">A list of strings representing all possible short-forms of the word W in lexicographical order.</p><h2 id="15758fd8-d211-80c5-b41f-c1c0d08a1ded" class="">Constraints:</h2><p id="15758fd8-d211-800a-b973-fd524eb72a02" class="">1 ≤ len(W) ≤ 10<br/>The word W consists of lowercase English letters only.<br/></p><h2 id="15758fd8-d211-80cc-8bb2-da47f9f8c841" class="">Sample Input-1:</h2><p id="15758fd8-d211-80b4-88c0-f8090aa0f6d1" class="">kmit</p><h2 id="15758fd8-d211-8087-ac0d-c620535e63f8" class="">Sample Output-1:</h2><p id="15758fd8-d211-802b-9f2a-c2ba32fd3cde" class="">[1m1t, 1m2, 1mi1, 1mit, 2i1, 2it, 3t, 4, k1i1, k1it, k2t, k3, km1t, km2, kmi1, kmit]</p><h2 id="15758fd8-d211-8044-930a-d6eb70d94a18" class="">Sample Input-2:</h2><p id="15758fd8-d211-8099-9cab-da9057d51da0" class="">cse</p><h2 id="15758fd8-d211-8096-8d33-fc500902d0d6" class="">Sample Output-2:</h2><p id="15758fd8-d211-8021-8009-fe4f36228364" class="">[1s1, 1se, 2e, 3, c1e, c2, cs1, cse]</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="15758fd8-d211-80bc-bd68-ef0f1ab830be" class="code"><code class="language-Java">import java.util.*;
    class GenerateAbbreviations{
        static List&lt;String&gt; binary=new ArrayList&lt;&gt;();
        public static void fun(int n,StringBuilder s)
        {
            if(n==0)
            {
            
                binary.add(s.toString());
                return ;
            }
            s.append(&#x27;0&#x27;);
            fun(n-1,s);
            s.deleteCharAt(s.length()-1);
            s.append(&#x27;1&#x27;);
            fun(n-1,s);
            s.deleteCharAt(s.length()-1);
        }
        public static void main(String[] args)
        {
            Scanner sc=new Scanner(System.in);
            String s=sc.nextLine();
            fun(s.length(),new StringBuilder());
            List&lt;String&gt; result=new ArrayList&lt;&gt;();
            System.out.println(binary);
            for(String l:binary)
            {
                StringBuilder res=new StringBuilder();
                int count=0;
                for(int i=0;i&lt;s.length();i++)
                {
                    if(l.charAt(i)==&#x27;1&#x27;)
                    {
                       count++;
                    }
                    else{
                        if(count&gt;0)
                        {
                            res.append(count);
                            count=0;
                        }
                        res.append(s.charAt(i));
                    }
                }
                if(count&gt;0)
                {
                    res.append(count);
                }
            
                result.add(res.toString());
            }
            Collections.sort(result);
            System.out.println(result);
        }
    }
    
    </code></pre><h2 id="15758fd8-d211-80bb-bf17-eab5cb504373" class=""><strong>Factor_Combinations</strong></h2><p id="15758fd8-d211-80da-a742-f6389698e534" class="">You are given an integer n.<br/>Your task is to find all possible unique combinations of integers greater than 1 that multiply together to form n.<br/></p><p id="15758fd8-d211-8072-abff-e5816a424588" class="">Each combination should be represented as a list of integers,<br/>and the combinations should be sorted lexicographically based on the factors.<br/>The output should not include duplicate combinations.<br/></p><h2 id="15758fd8-d211-808c-938b-dbd3b810d7c0" class="">Input Format:</h2><p id="15758fd8-d211-80b5-b278-d7bdf8a864b5" class="">Line-1: An integer n where n &gt; 1.</p><h2 id="15758fd8-d211-80a0-85e5-ecdd8da4da69" class="">Output Format:</h2><p id="15758fd8-d211-803f-83f7-cf90f5a98ef8" class="">Line-1: A list of lists, where each sublist contains integers that represent one valid factor combination of n.</p><h2 id="15758fd8-d211-80fb-8975-fc876f2b5fc4" class="">Sample Input-1:</h2><p id="15758fd8-d211-8002-a650-cf9b044d1a86" class="">12</p><h2 id="15758fd8-d211-80d6-8e7c-d3c8adfc2195" class="">Sample Output-1:</h2><p id="15758fd8-d211-80bb-9016-da07256b4beb" class="">[[2, 6], [2, 2, 3], [3, 4]]</p><h2 id="15758fd8-d211-8063-bfcd-e1c1be96b57c" class="">Sample Input-2:</h2><p id="15758fd8-d211-80bf-a5a8-c01243d3d435" class="">15</p><h2 id="15758fd8-d211-80ce-9d16-c268de9b8ed4" class="">Sample Output-2:</h2><p id="15758fd8-d211-8027-9844-c49c57c4cf8d" class="">[[3, 5]]</p><h2 id="15758fd8-d211-80ac-a2b1-ca5b355126e2" class="">Sample Input-3:</h2><p id="15758fd8-d211-804e-92d7-cef7f58ee2b4" class="">32</p><h2 id="15758fd8-d211-805b-85e1-e3bc9f9b1aa3" class="">Sample Output-3:</h2><p id="15758fd8-d211-804f-b55a-eb9feaa92c7e" class="">[[2, 16], [2, 2, 8], [2, 2, 2, 4], [2, 2, 2, 2, 2], [4, 8]]</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="15758fd8-d211-8027-ac89-fd222b066f09" class="code"><code class="language-Java">import java.util.*;
    
    class Solution {
        static void backtrack(int n, int start, List&lt;List&lt;Integer&gt;&gt; result, List&lt;Integer&gt; temp) {
            if (n == 1) {
                if (temp.size() &gt; 1) {
                    result.add(new ArrayList&lt;&gt;(temp));
                }
                return;
            }
            
            for (int i = start; i &lt;= n; i++) {
                if (n % i == 0) {  
                    temp.add(i); 
                    backtrack(n / i, i, result, temp); 
                    temp.remove(temp.size() - 1);
                }
            }
        }
    
        static List&lt;List&lt;Integer&gt;&gt; solve(int n) {
            List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();
            List&lt;Integer&gt; temp = new ArrayList&lt;&gt;();
            backtrack(n, 2, result, temp);
            return result;
        }
    
        public static void main(String[] args) {
            Scanner sc = new Scanner(System.in);
            int n = sc.nextInt();
            List&lt;List&lt;Integer&gt;&gt; result = solve(n); 
            System.out.println(result);
        }
    }
    </code></pre><h2 id="15758fd8-d211-809f-8c6f-e616c4c8d091" class=""><strong>Tile_Possibility</strong></h2><p id="15758fd8-d211-80d3-b861-ea4d0074d5d5" class="">You are given a string of uppercase English letters representing letter tiles. Each letter tile can be used once per combination.<br/>Your task is to determine the total number of possible sequences that can be formed using these letter tiles.<br/></p><p id="15758fd8-d211-80ff-b69a-cf2c75bfc616" class="">Rules:<br/>-The order of letters in a sequence matters.<br/>-A sequence can consist of any number of tiles (from 1 to the total number of tiles).<br/>-Duplicate tiles may lead to duplicate sequences, so consider each sequence as unique.<br/></p><h2 id="15758fd8-d211-801c-b7d7-d06ee0bce427" class="">Input Format:</h2><p id="15758fd8-d211-80a6-8c85-f531a9f949e5" class="">Line-1: A string tiles, where 1 ≤ tiles.length ≤ 7 and each character is an uppercase English letter.</p><h2 id="15758fd8-d211-80e4-8ccc-c2a73c1c1a9f" class="">Output Format:</h2><p id="15758fd8-d211-809b-a6bb-ed1c1937e5bc" class="">Line-1: An integer representing the total number of unique sequences that can be formed.</p><h2 id="15758fd8-d211-8062-992b-c4d08f54008a" class="">Sample Input-1:</h2><p id="15758fd8-d211-8016-b7a5-c78ad1b7e32a" class="">AAB</p><h2 id="15758fd8-d211-80a4-b6bd-f490e1a3bf15" class="">Sample Output-1:</h2><p id="15758fd8-d211-8072-9e43-f92268d9b121" class="">8</p><p id="15758fd8-d211-8087-886d-d72ddf90cfca" class="">Explanation:<br/>The sequences are: A, B, AA, AB, BA, AAB, ABA, BAA.<br/></p><h2 id="15758fd8-d211-80ce-9f47-e24c5817ace9" class="">Sample Input-2:</h2><p id="15758fd8-d211-80ef-bfcd-c57282dddb8d" class="">AAABBC</p><h2 id="15758fd8-d211-8033-ac89-e4f797f1756e" class="">Sample Output-2:</h2><p id="15758fd8-d211-8025-a023-feca8acd7e3b" class="">188</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="15758fd8-d211-800c-b435-c6ef3f792fe2" class="code"><code class="language-Java">import java.util.*;
    
    class Solution {
        public static void main(String[] args) {
            Scanner sc = new Scanner(System.in);
            String s = sc.next();
            
            Set&lt;String&gt; res = new HashSet&lt;&gt;();
    
            for (int len = 1; len &lt;= s.length(); len++) {
                getPerms(s.toCharArray(), 0, len, new boolean[s.length()], new StringBuilder(), res);
            }
            
    
            System.out.println(res.size());
        }
        
        static void getPerms(char[] chars, int ind, int len, boolean[] visited, StringBuilder sb, Set&lt;String&gt; set) {
            if (ind == len) {
                set.add(sb.toString());
                return;
            }
            
            for (int i = 0; i &lt; chars.length; i++) {
                if (!visited[i]) {
                    visited[i] = true;
                    sb.append(chars[i]);
                    getPerms(chars, ind + 1, len, visited, sb, set);
                    sb.deleteCharAt(sb.length() - 1);
                    visited[i] = false;
                }
            }
        }
    }
    </code></pre><h2 id="15758fd8-d211-80e6-aad6-dd6e71491a73" class=""><strong>Maze(BackTracking)</strong></h2><p id="15758fd8-d211-8005-a943-c141d5085f81" class="">You are entering into a maze N*N grid consist of(0&#x27;s and 1&#x27;s)<br/>Initially you will start from (0,0) position in the maze,<br/>Your target is to reach the end position (N-1, N-1).<br/></p><p id="15758fd8-d211-80f1-a417-d092079ac3f5" class="">Among the four directions available(top, down, left, right),<br/>you can move in two directions only, right and down.<br/></p><p id="15758fd8-d211-80cc-abfd-fc69f6e6526c" class="">In the maze, &#x27;0&#x27; indicates dead end and &#x27;1&#x27; indicates open way.<br/>You can travel through only open way.<br/>For Example:-<br/>Given Maze of size N=4 , starting position is (0, 0),<br/>1 0 0 0<br/>1 1 0 1<br/>0 1 0 0<br/>1 1 1 1<br/></p><p id="15758fd8-d211-80a0-89bf-e1fcc1f304fc" class="">You can reach the (3, 3) position in the following way.<br/>1 0 0 0<br/>1 1 0 0<br/>0 1 0 0<br/>0 1 1 1<br/></p><p id="15758fd8-d211-80ff-b1cb-e1982146327c" class="">Return true, if you can reach the end position(N-1, N-1).<br/>otherwise return false.<br/></p><h2 id="15758fd8-d211-8038-a9ac-caa02a6ac075" class="">Input Format:</h2><p id="15758fd8-d211-8070-af01-eb74cb2b354c" class="">Line-1 -&gt; An integer N, size of square board.<br/>Next N lines -&gt; N space separated integers<br/></p><h2 id="15758fd8-d211-8084-84b6-e42ff81fce0d" class="">Output Format:</h2><p id="15758fd8-d211-803f-8733-f358ea55e15a" class="">Print a boolean value.</p><h2 id="15758fd8-d211-809a-a09e-c63ac94433c1" class="">Sample Input-1:</h2><p id="15758fd8-d211-8017-84a2-c5d350e4ba95" class="">4<br/>1 0 0 0<br/>1 1 0 1<br/>0 1 0 0<br/>1 1 1 1<br/></p><h2 id="15758fd8-d211-80e7-931b-e699d6f924a2" class="">Sample Output-1:</h2><p id="15758fd8-d211-8032-8094-d3be1b1330a3" class="">true</p><h2 id="15758fd8-d211-80c0-a5b6-ff3995322b63" class="">Sample Input-2:</h2><p id="15758fd8-d211-80b2-964c-ca6c32990bb8" class="">4<br/>1 1 0 0<br/>1 0 0 1<br/>0 1 1 0<br/>1 0 0 1<br/></p><h2 id="15758fd8-d211-80d6-bf31-de8297ba513c" class="">Sample Output-2:</h2><p id="15758fd8-d211-80e1-a051-fca431bd99e4" class="">false</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="15758fd8-d211-80fd-b438-fd313403474b" class="code"><code class="language-Java">import java.util.*;
    
    class Maze {
    
        static boolean dfs(int[][] grid, boolean[][] vis, int n, int r, int c) {
    
            if (r == n - 1 &amp;&amp; c == n - 1 &amp;&amp; grid[r][c] == 1) {
                return true;
            }
    
            int[][] dir = new int[][]{{1, 0}, {0, 1}};
            for (int i = 0; i &lt; 2; i++) {
                int nr = r + dir[i][0];
                int nc = c + dir[i][1];
                
                if (nr &gt;= 0 &amp;&amp; nc &gt;= 0 &amp;&amp; nr &lt; n &amp;&amp; nc &lt; n &amp;&amp; grid[nr][nc] == 1 &amp;&amp; !vis[nr][nc]) {
                    vis[nr][nc] = true; 
                    if (dfs(grid, vis, n, nr, nc)) {
                        return true;
                    }
                    vis[nr][nc] = false;
                }
            }
            
            return false;
        }
    
        static void solve(int[][] grid, int n) {
            boolean[][] vis = new boolean[n][n];
            for (int i = 0; i &lt; n; i++) {
                Arrays.fill(vis[i], false);
            }
            System.out.println(dfs(grid, vis, n, 0, 0));
        }
    
        public static void main(String[] args) {
            Scanner sc = new Scanner(System.in);
            int n = sc.nextInt();
            int grid[][] = new int[n][n];
            for (int i = 0; i &lt; n; i++) {
                for (int j = 0; j &lt; n; j++) {
                    grid[i][j] = sc.nextInt();
                }
            }
            solve(grid, n);
        }
    }
    </code></pre><h1 id="15858fd8-d211-8003-8c43-eab4e0e92259" class="">DYNAMIC PROGRAMMING</h1><h2 id="15858fd8-d211-80b7-9f64-c0846d8ca5d8" class="">Climbing Stairs</h2><p id="15858fd8-d211-80e3-af3a-cfe0b6cefb4e" class="">// Sharath is playing a game where he has to cross N levels to win.</p><p id="15858fd8-d211-8041-9d88-f56bdfded945" class="">// The rules of the game allow Sharath to take one of the following steps:<br/>//     -Jump 1 level in one step.<br/>//     -Jump 2 levels in one step.<br/></p><p id="15858fd8-d211-807a-a111-d6392478ab46" class="">// Your task is to determine the number of distinct ways Sharath can reach the Nth level.</p><p id="15858fd8-d211-80eb-9e5c-daa5accd1be2" class="">// Constraints:</p><p id="15858fd8-d211-8008-8c0f-fd6668a0e4c3" class="">//     1 &lt;= N &lt;= 45</p><p id="15858fd8-d211-80cc-83c3-de3262896c25" class="">// Input Format:<br/>// -------------<br/>// Line-1: An Integer N represents number of levels.<br/></p><p id="15858fd8-d211-8080-86e5-dc78d089774c" class="">// Output Format:<br/>// --------------<br/>// Print an integer.<br/></p><p id="15858fd8-d211-8032-aafe-cc35648d185f" class="">// Sample Input-1:<br/>// ---------------<br/>// 2<br/></p><p id="15858fd8-d211-80bb-9dc0-fb489bfa0be8" class="">// Sample Output-1:<br/>// ----------------<br/>// 2<br/></p><p id="15858fd8-d211-8096-917b-e8d4622a0ab6" class="">// Explanation:<br/>// ------------<br/>// 1. 1-level+ 1-level =2<br/>// 2. 2 levels in one step.<br/></p><p id="15858fd8-d211-805c-ac45-e9a9e617b9db" class="">// Sample Input-2:<br/>// ---------------<br/>// 4<br/></p><p id="15858fd8-d211-80c8-9e22-cbdac0e7bb44" class="">// Sample Output-2:<br/>// ----------------<br/>// 5<br/></p><p id="15858fd8-d211-8043-89ad-c7610d8344f5" class="">// Explanation:<br/>// ------------<br/>// 1. 1-level + 1-level + 1-level + 1-level = 4<br/>// 2. 1-level + 1-level + 2-levels = 4<br/>// 3. 1-level + 2-levels + 1-level = 4<br/>// 4. 2-levels + 1-level + 1-level = 4<br/>// 5. 2-levels + 2-levels  = 4<br/></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="15858fd8-d211-8064-80a1-eab8731dcabd" class="code"><code class="language-Java">import java.util.*;
    
    // Memoization
    
    public class climbingStairs{
        public static int fibonacci(int n, HashMap&lt;Integer,Integer&gt; map){
            if(n==1){
                return n;
            }
            if(map.containsKey(n)){
                return map.get(n);
            }
            Integer fiboN = fibonacci(n-1,map) + fibonacci(n-2,map);
            map.put(n,fiboN);
            return fiboN;
        }
        public static void main(String[] args){
            Scanner sc = new Scanner(System.in);
            int n = sc.nextInt();
            if(n==0){
                System.out.println(0);
                sc.close();
                return;
            }
            HashMap&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;();
            map.put(0,0);
            map.put(1,1);
            System.out.println(fibonacci(n+1,map));
            sc.close();
        }</code></pre><p id="15858fd8-d211-80ab-abdd-f626eb74c16d" class="">
    </p><h2 id="15758fd8-d211-8002-91fd-faec11729568" class=""><strong>MinCost_Climbing_Stairs</strong></h2><p id="15858fd8-d211-8041-a5ae-f01be75d4353" class="">// Pavan is playing a game where there are N levels and each level has some points in it.<br/>// level[i] is the points to spend on ith level(0-indexed) to move forward.<br/>// Inorder to win the game he has to reach the top level.<br/></p><p id="15858fd8-d211-8010-8bbb-ddbfa6f43d16" class="">// The rule book explains &quot;In one step you have to spend the points given on the<br/>// present level and you can either cross one level or two levels forward&quot;.<br/></p><p id="15858fd8-d211-8030-ac00-ca7595349942" class="">// Return the minimum number of points to spend to win the game.</p><p id="15858fd8-d211-80bf-9a1b-dd47cb8f1137" class="">// Note:You are allowed to start at either level-0 or level-1.</p><p id="15858fd8-d211-8070-a2b8-d2006031e6c7" class="">// Constraints:<br/>// -------------<br/>//     2 &lt;= N &lt;=1000<br/>//     0 &lt;= level[i] &lt;= 999<br/></p><p id="15858fd8-d211-80c5-b083-fde3f5d1ac1e" class="">// Input Format:<br/>// -------------<br/>// Line-1: An integer N, representing the number of levels.<br/>// Line-2: N space-separated integers, representing the points required for each level.<br/></p><p id="15858fd8-d211-8096-96ae-f7900db5a0f4" class="">// Output Format:<br/>// --------------<br/>// Line-1: Print an integer, representing the minimum number of points needed to win the game.<br/></p><p id="15858fd8-d211-8095-a5fa-e4f5bd550f50" class="">// Sample Input-1:<br/>// ---------------<br/>// 3<br/>// 20 30 40<br/></p><p id="15858fd8-d211-80f8-bfed-d6a786d0db17" class="">// Sample Output-1:<br/>// ----------------<br/>// 30<br/></p><p id="15858fd8-d211-80b3-ac3e-c8803f6a6a30" class="">// Explanation:<br/>// ------------<br/>// Pavan can start at index-1 by spending points 30 and he can win.<br/></p><p id="15858fd8-d211-80f5-a629-ea62f0981553" class="">// Sample Input-2:<br/>// ---------------<br/>// 7<br/>// 2 3 50 2 2 50 2<br/></p><p id="15858fd8-d211-807b-bc3a-ea63730628e3" class="">// Sample Output-2:<br/>// ----------------<br/>// 9<br/></p><p id="15858fd8-d211-801b-9564-f12161f2caed" class="">// Explanation:<br/>// ------------<br/>// Start at index-1:<br/>//   -Spend 3 points and reach to index-3<br/>//   -Spend 2 points and reach to index-4<br/>//   -Spend 2 points and reach to index-6<br/>//   -Spend 2 points and he wins.<br/></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="15858fd8-d211-805c-b0e5-e59a94d4f6b6" class="code"><code class="language-Java">import java.util.*;
    
    public class minCostClimbingStairs{
        public static int getMinCost(int[] arr, int n){
            int[] dp = new int[n];
            dp[0] = arr[0];
            dp[1] = arr[1];
            for(int i = 2;i&lt;n;i++){
                dp[i] = arr[i] + Math.min(dp[i-1],dp[i-2]);
            }
            return Math.min(dp[n-1],dp[n-2]);
        }
        public static void main(String[] args){
            Scanner sc = new Scanner(System.in);
            int n = sc.nextInt();
            int[] arr = new int[n];
            for(int i = 0;i&lt;n;i++){
                arr[i] = sc.nextInt();
            }
            System.out.println(getMinCost(arr,n));
            sc.close();
        }
    }</code></pre><p id="15858fd8-d211-80fd-bdef-f677068c9c80" class="">
    </p><p id="15858fd8-d211-80b7-a304-c146e304f954" class="">
    </p><p id="15758fd8-d211-804c-bbeb-f694cb680fd6" class="">
    </p><h2 id="15758fd8-d211-80fc-9a04-d482356b9137" class=""><strong>0/1_Knapsack</strong></h2><p id="15858fd8-d211-803d-8292-d13f43487ef1" class="">// Mr. Dharma is shopping at D-Mart with a basket that has a capacity C.<br/>// He has a wishlist of N products, where each product has a cost and a quantity.<br/></p><p id="15858fd8-d211-805d-8cc9-f220ca3fdccb" class="">// His goal is to purchase products in such a way that:<br/>// 	-The total quantity of the selected products does not exceed the basket capacity C.<br/>// 	-The total cost of the selected products is maximized among all possible combinations.<br/></p><p id="15858fd8-d211-80c5-884e-ddf0a8ab18bd" class="">// Your task is to help Mr. Dharma determine the maximum cost he can achieve under the given constraints.</p><p id="15858fd8-d211-8011-9bfa-c9cdf94a416e" class="">// Input Format:<br/>// --------------<br/>// Line-1: Two space-separated integers N and C, representing the number of products and the basket capacity, respectively.<br/>// Next N lines: Two space-separated integers Ci and Qi, representing the cost and quantity of the ith product.<br/></p><p id="15858fd8-d211-802a-9048-d37c55fe7aac" class="">// Output Format:<br/>// --------------<br/>// Line-1: Print an integer, the maximum cost Mr. Dharma can achieve.<br/></p><p id="15858fd8-d211-8086-a555-f458cf399983" class="">// Constraints:<br/>// ------------<br/>// *1≤N≤100 (Number of products)<br/>// *1≤C≤1000 (Basket capacity)<br/>// *1≤Ci,Qi≤100 (Cost and quantity of each product)<br/></p><p id="15858fd8-d211-808b-861f-e5e83edd3522" class="">// Sample Input-1:<br/>// ---------------<br/>// 4 15<br/>// 10 2<br/>// 10 4<br/>// 12 6<br/>// 18 9<br/></p><p id="15858fd8-d211-80ce-ad2d-d1ca28b5b84a" class="">// Sample Output-1:<br/>// ----------------<br/>// 38<br/></p><p id="15858fd8-d211-8068-a7fd-d2e0b427d113" class="">// Explanation:<br/>// ------------<br/>// The selected products are:<br/>// 	Product 1 (Cost = 10, Quantity = 2)<br/>// 	Product 2 (Cost = 10, Quantity = 4)<br/>// 	Product 4 (Cost = 18, Quantity = 9)<br/></p><p id="15858fd8-d211-80f9-9b16-d6753c85da0c" class="">// Total cost = 10 + 10 + 18 = 38<br/>// Total quantity = 2 + 4 + 9 = 15<br/></p><p id="15858fd8-d211-8025-b260-e485ef22b4ca" class="">// Sample Input-2:<br/>// ---------------<br/>// 4 21<br/>// 18 6<br/>// 20 3<br/>// 14 5<br/>// 18 9<br/></p><p id="15858fd8-d211-8030-bdf9-f3059c76d2ad" class="">// Sample Output-2:<br/>// ----------------<br/>// 56<br/></p><p id="15858fd8-d211-80fe-a7c8-dd805d632086" class="">// Explanation:<br/>// ------------<br/>// The selected products are:<br/>// 	Product 1 (Cost = 18, Quantity = 6)<br/>// 	Product 2 (Cost = 20, Quantity = 3)<br/>// 	Product 4 (Cost = 18, Quantity = 9)<br/></p><p id="15858fd8-d211-8015-8d56-cde7bd8bff8d" class="">// Total cost = 18 + 20 + 18 = 56<br/>// Total quantity = 6 + 3 + 9 = 18<br/></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="15858fd8-d211-80bb-b58e-fa02cb04b7bb" class="code"><code class="language-Java">import java.util.*;
    
    public class ZeroOneKnapsack{
        public static int maxCost(int[] weight, int[] value, int n, int wt){
            int[][] dp = new int[n+1][wt+1];
            for(int i = 1;i&lt;=n;i++){
                for(int w = 1;w&lt;=wt;w++){
                    if(w&gt;=weight[i-1]){
                        dp[i][w] = Math.max(dp[i-1][w],dp[i-1][w-weight[i-1]]+value[i-1]);
                    }
                    else{
                        dp[i][w] = dp[i-1][w];
                    }
                }
            }
            return dp[n][wt];
        }
        public static void main(String[] args){
            Scanner sc = new Scanner(System.in);
            int n = sc.nextInt();
            int wt = sc.nextInt();
            int[] weight = new int[n];
            int[] value = new int[n];
            for(int i = 0;i&lt;n;i++){
                value[i] = sc.nextInt();
                weight[i] = sc.nextInt();
            }
            System.out.println(maxCost(weight,value,n,wt));
            sc.close();
        }
    }</code></pre><h2 id="15858fd8-d211-805c-947f-dc14cebc2607" class="">HOUSE ROBBER</h2><p id="15858fd8-d211-8058-b0bd-e8e6c68666a7" class="">// A group of houses is arranged in a street, and each house has a certain amount of money stashed inside.<br/>// A robber wants to steal the maximum amount of money possible.<br/>// However, there is a catch:<br/>// &quot;the robber cannot rob two adjacent houses as it will alert the police.&quot;<br/></p><p id="15858fd8-d211-805f-9ba0-df4e984b29fc" class="">// You are tasked to calculate the maximum amount of money the robber can steal without alerting the police.</p><p id="15858fd8-d211-801a-bb9b-d8baf7dc7fae" class="">// Input Format:<br/>// -------------<br/>// Line-1: An integer n, representing the number of houses in the street.<br/>// Line-2: n space-separated integers, representing the money stashed in each house.<br/></p><p id="15858fd8-d211-8087-8112-de80df4e2df0" class="">// Output Format:<br/>// --------------<br/>// Line-1: An integer, Print the maximum amount of money the robber can steal without alerting the police.<br/></p><p id="15858fd8-d211-8065-991e-def67d311b9b" class="">// Sample Input-1:<br/>// ---------------<br/>// 5<br/>// 100 50 400 200 100<br/></p><p id="15858fd8-d211-80e0-9a8a-e8693972ce34" class="">// Sample Output-1:<br/>// ----------------<br/>// 600<br/></p><p id="15858fd8-d211-8021-94ae-d2f758e80e32" class="">// Explanation:<br/>// ------------<br/>// The robber will steal 100, 400 and 100 from the houses.<br/>// Refer Hint for more.<br/></p><p id="15858fd8-d211-80c9-95f1-f5a98efd5453" class="">// Sample Input-2:<br/>// ---------------<br/>// 5<br/>// 5 3 4 11 2<br/></p><p id="15858fd8-d211-8052-8429-d1a2b34108ee" class="">// Sample Output-2:<br/>// ----------------<br/>// 16<br/></p><p id="15858fd8-d211-8036-98c2-c0c11e66c43c" class="">// Explanation:<br/>// ------------<br/>// Thief will steal 5 and 11 from the houses.<br/></p><p id="15858fd8-d211-80aa-83cf-dad8ec1a9d21" class="">
    </p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="15858fd8-d211-800a-aab7-cf1c98751d96" class="code"><code class="language-Java">import java.util.*;
    
    public class houseRobber{
        public static int maxMoney(int[] houses, int n){
            if(n==0){
                return 0;
            }
            if(n==1){
                return houses[0];
            }
            if(n==2){
                return Math.max(houses[0],houses[1]);
            }
            int[] dp = new int[n];
            dp[0] = houses[0];
            dp[1] = Math.max(houses[0],houses[1]);
            for(int i=2;i&lt;n;i++){
                dp[i] = Math.max(dp[i-1],dp[i-2]+houses[i]);
            }
            return dp[n-1];
        }
        public static void main(String[] args){
            Scanner sc = new Scanner(System.in);
            int n = sc.nextInt();
            int[] houses = new int[n];
            for(int i=0;i&lt;n;i++){
                houses[i] = sc.nextInt();
            }
            System.out.println(maxMoney(houses,n));
            sc.close();
        }
    }</code></pre><h2 id="15758fd8-d211-8055-90f6-d51c4efeecf6" class=""><strong>Maximum_Sub_Array</strong></h2><p id="15858fd8-d211-8028-9c81-e90c5fa22196" class="">// You are playing a game. There are N boxes placed in a row (0-indexed),<br/>// every box has some points.<br/></p><p id="15858fd8-d211-809e-9998-f62bd7f19953" class="">// You need to play the game with the following rules:<br/>//     - Initially your score is  &#x27;0&#x27; points.<br/>// 	- Suppose the box has P points in it.<br/>// 	  if p&gt;0 you will gain P points, if p&lt;0 you will loose P points.<br/>// 	- You are allowed to choose any number of consecutive boxes, atleast 1 box.<br/></p><p id="15858fd8-d211-8073-b361-ef5f6ff13045" class="">// You are given the points in the N boxes as points[].<br/>// Your target is to maximize your score, and return the highest score possible.<br/></p><p id="15858fd8-d211-80b4-8fd0-d2cbc7abdcc6" class="">// Input Format:<br/>// -------------<br/>// Line-1: An integer N.<br/>// Line-2: N space separated integers, points[].<br/></p><p id="15858fd8-d211-80aa-badc-f271f9d40a40" class="">// Output Format:<br/>// --------------<br/>// An integer, print the highest score.<br/></p><p id="15858fd8-d211-80df-89be-e240559125a0" class="">// Sample Input-1:<br/>// ---------------<br/>// 9<br/>// -3 1 -2 4 -2 2 3 -5 4<br/></p><p id="15858fd8-d211-8002-9e08-d5dbf56b867c" class="">// Sample Output-1:<br/>// ----------------<br/>// 7<br/></p><p id="15858fd8-d211-8081-a957-f4fd9f38c14d" class="">// Explanation:<br/>// ------------<br/>// By selecting consecutive boxes are [4,-2,2,3] has the highest score is 7<br/></p><p id="15858fd8-d211-80a3-937d-f4c9a5172701" class="">// Sample Input-2:<br/>// ---------------<br/>// 2<br/>// 1 -2<br/></p><p id="15858fd8-d211-80fa-8ad2-f4b2a2be92bc" class="">// Sample Output-2:<br/>// ----------------<br/>// 1<br/></p><p id="15858fd8-d211-80bf-8112-e2931051be00" class="">// Explanation:<br/>// ------------<br/>// By picking the box is [1] has the highest score is 1.<br/></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="15758fd8-d211-801e-94cf-ec6378da980a" class="code"><code class="language-Java">import java.util.*;
    
    public class MaxSubArray_Non_Memoization{
        public static int maxSubArray(int[] arr, int n){
            int max = Integer.MIN_VALUE;
            int sum = 0;
            for(int i = 0;i&lt;n;i++){
                sum += arr[i];
                max = Math.max(max,sum);
                if(sum&lt;0){
                    sum = 0;
                }
            }
            return max;
        }
        public static void main(String[] args){
            Scanner sc = new Scanner(System.in);
            int n = sc.nextInt();
            int[] arr = new int[n];
            for(int i = 0;i&lt;n;i++){
                arr[i] = sc.nextInt();
            }
            System.out.println(maxSubArray(arr,n));
            sc.close();
        }
    }</code></pre><p id="15858fd8-d211-8095-be65-d51f9d3df409" class="">TABULATION</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="15858fd8-d211-80d6-b2b4-ea14264a31ab" class="code"><code class="language-Java">import java.util.*;
    
    public class MaxSubArray_Tabulation{
        public static int maxSubArray(int[] arr, int n){
            int[] dp = new int[n];
            dp[0] = arr[0];
            int max = dp[0];
            for(int i = 1;i&lt;n;i++){
                dp[i] = arr[i] + (dp[i-1]&gt;0?dp[i-1]:0);
                max = Math.max(max,dp[i]);
            }
            return max;
        }
        public static void main(String[] args){
            Scanner sc = new Scanner(System.in);
            int n = sc.nextInt();
            int[] arr = new int[n];
            for(int i = 0;i&lt;n;i++){
                arr[i] = sc.nextInt();
            }
            System.out.println(maxSubArray(arr,n));
            sc.close();
        }
    }</code></pre><h2 id="15758fd8-d211-808c-b5f6-fd8f5afc8297" class=""><strong>MatrixMultiplication_Memoized</strong><br/><br/></h2><p id="15758fd8-d211-8053-af18-f506d6415ae0" class="">Your are given the sizes of N-1 matrices as a list[] of size N,<br/>where the matrix are numbered from 0 to N-2<br/>and the matrix size is defined as matrix-i size is list[i]*list[i+1].<br/></p><p id="15758fd8-d211-80cb-b761-e8f71a2a979d" class="">Matrix multiplication follows associative rule. If you want to multiply 4 matrices, A,B,C and D.<br/>You can perform multiplication in the following ways, ABCD, AB(CD), A(BC)D, ((AB)C)D, (AB)(CD)..etc.<br/>To multiply two matrices of size m<br/><em>n, n</em>p, you require m<em>n</em>p number of multiplications.</p><p id="15758fd8-d211-8014-8c05-f66a6e6769d2" class="">Your task is to return the minimum number of multiplications needed to multiply the N-1 matrices.</p><h2 id="15758fd8-d211-805a-a4df-dd829d07c41f" class="">Input Format:</h2><p id="15758fd8-d211-80a5-9259-e13d8996b83f" class="">Line-1: An integer N<br/>Line-2: N space separated integers, the list[]<br/></p><h2 id="15758fd8-d211-806a-9eb2-f73979238bc4" class="">Output Format:</h2><p id="15758fd8-d211-8015-b0ec-e1d6bb22443a" class="">Print an integer, minimum multiplications needed.</p><h2 id="15758fd8-d211-80c6-ba27-f958b815cda5" class="">Sample Input-1:</h2><p id="15758fd8-d211-8049-9243-f8ae7adcc986" class="">4<br/>10 30 5 60<br/></p><h2 id="15758fd8-d211-801b-b463-c0a7f0e3d3b0" class="">Sample Output-1:</h2><p id="15758fd8-d211-800d-9f16-e7b67ef01216" class="">4500</p><h2 id="15758fd8-d211-8033-9ac1-d616ad908fa8" class="">Explanation:</h2><p id="15758fd8-d211-8091-ba14-c338a73c4ecd" class="">posibilities are:<br/>(AB)C =&gt; (10×30×5) + (10×5×60) =&gt; 1500 + 3000 = 4500 multiplications<br/>A(BC) =&gt; (30×5×60) + (10×30×60) =&gt; 9000 + 18000 = 27000 multiplications<br/></p><h2 id="15758fd8-d211-80eb-ab80-eb91ec4ceb0f" class="">Sample Input-2:</h2><p id="15758fd8-d211-8078-808a-e20c882c772c" class="">5<br/>12 5 18 7 19<br/></p><h2 id="15758fd8-d211-8077-8fae-f22c4cca6b9c" class="">Sample Output-2:</h2><p id="15758fd8-d211-8091-a9dc-ea53e26897e1" class="">2435</p><h2 id="15758fd8-d211-800c-bb22-e2ad470a6e62" class="">Explanation:</h2><p id="15758fd8-d211-8015-894e-deca4c32abf4" class="">The best way is: A((BC)D) =&gt; (12<em>5</em>19) + (5<em>18</em>7) + (5<em>7</em>19)<br/>=&gt; 1140 + 630 + 665 = 2435 multiplications<br/></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="15758fd8-d211-8006-9ac4-c85f14b69a92" class="code"><code class="language-Java">import java.util.*;
    
    public class MatrixChainMultiplication{
        public static int matrixChainOrder(int[] arr, int i, int j){
            if(i==j){
                return 0;
            }
            int res = Integer.MAX_VALUE;
            for(int k=i;k&lt;j;k++){
                int count = matrixChainOrder(arr,i,k);
                count += matrixChainOrder(arr,k+1,j);
                count += arr[i-1]*arr[k]*arr[j];
                res = Math.min(res,count);
            }
            return res;
        }
        public static void main(String[] args){
            Scanner sc = new Scanner(System.in);
            int n = sc.nextInt();
            int[] arr = new int[n];
            for(int i = 0;i&lt;n;i++){
                arr[i] = sc.nextInt();
            }
            System.out.println(matrixChainOrder(arr,1,n-1));
            sc.close();
        }
    }</code></pre><p id="15758fd8-d211-8055-bd85-d3267ac169e6" class="">TABULATION</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="15858fd8-d211-8067-a492-d97bd24ba218" class="code"><code class="language-Java">import java.util.*;
    public class MatrixChainMultiplication_DP_Tabulation {
        public static int matrixChainMultiplication(int[] arr,int n, int[][] dp){
            for(int len = 1; len&lt;n-1;len++){
                for(int i = 1; i&lt;n-len;i++){
                    int j = i+len;
                    dp[i][j] = Integer.MAX_VALUE;
                    for(int k = i;k&lt;j;k++){
                        int cost = dp[i][k] + dp[k+1][j] + arr[i-1]*arr[k]*arr[j];
                        dp[i][j] = Math.min(dp[i][j],cost);
                    }
                }
            }
            return dp[1][n-1];
        }
        public static int matrixChainOrder(int[] arr, int n){
            int[][] dp = new int[n][n];
            return matrixChainMultiplication(arr,n,dp);
        }
        public static void main(String[] args) {
            Scanner sc = new Scanner(System.in);
            int n = sc.nextInt();
            int[] arr = new int[n];
            for(int i = 0;i&lt;n;i++){
                arr[i] = sc.nextInt();
            }
            System.out.println(matrixChainOrder(arr,n));
            sc.close();
    
        }
    }</code></pre><p id="15858fd8-d211-80a9-817f-c14b5478eb5a" class="">MEMOIZATION</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="15858fd8-d211-8037-8607-db332f29fd4e" class="code"><code class="language-Java">import java.util.*;
    public class MatrixChainMultiplication_Memoization {
        public static int matrixChainMultiplication(int[] arr, int i, int j, int[][] dp){
            if(i==j){
                return 0;
            }
            if(dp[i][j] != 0){
                return dp[i][j];
            }
            dp[i][j] = Integer.MAX_VALUE;
            for(int k = i;k&lt;j;k++){
                dp[i][j] = Math.min(dp[i][j],matrixChainMultiplication(arr, i, k, dp)+matrixChainMultiplication(arr, k+1, j, dp) + arr[i-1]*arr[k]*arr[j]);
            }
            return dp[i][j];
        }
        public static int matrixChainOrder(int[] arr, int i, int n){
            int[][] dp = new int[n][n];
            return matrixChainMultiplication(arr,i,n-1,dp);
        }
        public static void main(String[] args) {
            Scanner sc = new Scanner(System.in);
            int n = sc.nextInt();
            int[] arr = new int[n];
            for(int i = 0;i&lt;n;i++){
                arr[i] = sc.nextInt();
            }
            System.out.println(matrixChainOrder(arr,1,n));
            sc.close();
    
        }
    }</code></pre><p id="15858fd8-d211-8023-823a-c2bd27442990" class="">
    </p><p id="15858fd8-d211-801e-8d1c-e44a31a8ad3e" class="">
    </p><p id="15758fd8-d211-804a-a3c1-c14d103b71ad" class="">
    </p><h2 id="15758fd8-d211-80e6-8b4b-e28e36103033" class=""><strong>Count_Corner_Rectangles</strong></h2><p id="15858fd8-d211-80df-9079-c9b8c1c3cf1b" class="">// JVS Infra Pvt Ltd purchased a flatland of size M<em>N, and it is divided<br/>// into 1<br/></em>1 cells. They mave marked some cells with red colors indicated<br/>// with 1 and other cells with blue color indicated with 0.<br/></p><p id="15858fd8-d211-808a-8f17-dadbd190ba59" class="">// They want to build the walls in the form of rectangles by connecting four distinct<br/>// red colored cells on the flatland that forms an axis-aligned rectangle.<br/>// And only the corners of the walls need to be red colored.<br/></p><p id="15858fd8-d211-80c8-95bd-e6d16d2c9690" class="">// Your task is to help, JVS Infra to count the number of rectangular walls<br/>// can be built by connecting the red colored cells on the flatland.<br/></p><p id="15858fd8-d211-8074-abd2-d8683234a148" class="">// Input Format:<br/>// -------------<br/>// Line-1: Two space separated integers, M and N<br/>// Next M lines: N space separated integers, either 0 or 1 only.<br/></p><p id="15858fd8-d211-809d-9b3d-d53c707446b9" class="">// Output Format:<br/>// --------------<br/>// Print an integer result.<br/></p><p id="15858fd8-d211-80b0-b2cb-cf1d8cc52dc5" class="">// Sample Input-1:<br/>// ---------------<br/>// 3 4<br/>// 1 0 1 0<br/>// 1 1 1 1<br/>// 0 1 1 1<br/></p><p id="15858fd8-d211-80b1-badb-e965e5376371" class="">// Sample Output-1:<br/>// ----------------<br/>// 4<br/></p><p id="15858fd8-d211-8042-a103-ed339d2676ac" class="">// Explanation:<br/>// -----------<br/>// Given flatland is:<br/>// 1 0 1 0<br/>// 1 1 1 1<br/>// 0 1 1 1<br/>// Number of rectangular walls are: 4<br/>// rectangle-1: by connecting 1&#x27;s at (0, 0), (1, 0), (0, 2), (1, 2)<br/>// rectangle-2: by connecting 1&#x27;s at (1, 1), (1, 2), (2, 1), (2, 2)<br/>// rectangle-3: by connecting 1&#x27;s at (1, 1), (1, 3), (2, 1), (2, 3)<br/>// rectangle-4: by connecting 1&#x27;s at (1, 2), (2, 2), (1, 3), (2, 3)<br/></p><p id="15858fd8-d211-80c5-9aff-d6e7591c272b" class="">// Sample Input-2:<br/>// ---------------<br/>// 4 5<br/>// 1 0 1 0 1<br/>// 0 0 0 1 0<br/>// 0 1 1 0 1<br/>// 1 0 1 0 0<br/></p><p id="15858fd8-d211-80b5-8581-d7ccd5f8b347" class="">// Sample Output-2:<br/>// ----------------<br/>// 2<br/></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="15858fd8-d211-8070-9a87-f128fb0cce7c" class="code"><code class="language-Java">import java.util.*;
    
    public class CountCornerRectangles{
        public static int countRectangles(int[][] arr, int n, int m){
            int res = 0;
            for(int i = 0;i&lt;n;i++){
                for(int j = i+1;j&lt;n;j++){
                    for(int k = 0,counter=0;k&lt;m;k++){
                        if(arr[i][k] + arr[j][k] == 2){
                            res += counter++;
                        }
                    }
                }
            }
            return res;
        }
        public static void main(String[] args){
            Scanner sc = new Scanner(System.in);
            int n = sc.nextInt();
            int m = sc.nextInt();
            int[][] arr = new int[n][m];
    
            for(int i = 0;i&lt;n;i++){
                for(int j = 0;j&lt;m;j++){
                    arr[i][j] = sc.nextInt();
                }
            }
    
            System.out.println(countRectangles(arr, n, m));
            sc.close();
        }
    }</code></pre><p id="15758fd8-d211-80e3-8bb4-dd653b921d7f" class="">
    </p><h2 id="15758fd8-d211-8091-969a-f938f29ad233" class=""><strong>All_Pairs_Shortest_Path</strong></h2><p id="15858fd8-d211-807c-beca-cf189b8fd075" class="">// Mr Abdul planned to visit all the tourist paths in a city.<br/>// There are P number of tourist places connected using some routes<br/>// in a city, the routes are one-directional.<br/></p><p id="15858fd8-d211-8045-a39e-d7756a98f4a5" class="">// Your task is to help Mr Abdul, to find the shortest routes between every pair<br/>// of tourist-places in the city.<br/></p><p id="15858fd8-d211-8032-97d9-ce8206531f1a" class="">// Input Format:<br/>// ------------------<br/>// Line-1: An integer P, number of places.<br/>// Next P lines: P space separated integers, the routes[][].<br/></p><p id="15858fd8-d211-8073-a77e-df27d556506b" class="">// Value 99 represents infinity (Large value)</p><p id="15858fd8-d211-80ac-93f8-f6cc88dd6740" class="">// Output Format:<br/>// --------------------<br/>// Print the shortest distance routes[][].<br/></p><p id="15858fd8-d211-8026-a709-e2658f56027b" class="">// Sample Input-1:<br/>// --------------------<br/>// 4<br/>// 0 5 99 10<br/>// 99 0 3 99<br/>// 99 99 0 1<br/>// 99 99 99 0<br/></p><p id="15858fd8-d211-8082-ae2d-eb50d6701bb6" class="">// Sample Output-1:<br/>// ----------------------<br/>// 0 5 8 9<br/>// INF 0 3 4<br/>// INF INF 0 1<br/>// INF INF INF 0<br/></p><p id="15858fd8-d211-80b3-9d86-eaa4aedb4b94" class="">// Sample Input-2:<br/>// --------------------<br/>// 5<br/>// 0 4 5 6 99<br/>// 99 0 5 99 10<br/>// 1 99 0 3 99<br/>// 2 99 99 0 1<br/>// 1 99 99 99 0<br/></p><p id="15858fd8-d211-80d1-b1c9-c6153b19ce66" class="">// Sample Output-2:<br/>// ----------------------<br/>// 0 4 5 6 7<br/>// 6 0 5 8 9<br/>// 1 5 0 3 4<br/>// 2 6 7 0 1<br/>// 1 5 6 7 0<br/></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="15758fd8-d211-8003-a400-eae93f0e0388" class="code"><code class="language-Java">import java.util.*;
    public class allPairsShortest_Floyd {
        public static void floydWarshall(int[][] grid, int v){
            int[][] dist = new int[v][v];
            for(int i = 0;i&lt;v;i++){
                for(int j = 0;j&lt;v;j++){
                    dist[i][j] = grid[i][j];
                }
            }
    
            for(int k = 0;k&lt;v;k++){
                for(int i = 0;i&lt;v;i++){
                    for(int j = 0;j&lt;v;j++){
                        if(dist[i][j] &gt; dist[i][k] + dist[k][j]){
                            dist[i][j] = dist[i][k] + dist[k][j];
                            System.out.println(dist[i][j]);
                        }
                    }
                }
            }
            for(int i = 0;i&lt;v;i++){
                for(int j = 0;j&lt;v;j++){
                    if(dist[i][j] == 99){
                        System.out.print(&quot;INF&quot; + &quot; &quot;);
                    }
                    else{
                        System.out.print(dist[i][j] + &quot; &quot;);
                    }
                }
                System.out.println(&quot;&quot;);
            }
        }
        public static void main(String[] args) {
            Scanner sc = new Scanner(System.in);
            int v = sc.nextInt();
            int[][] grid = new int[v][v];
            for(int i = 0;i&lt;v;i++){
                for(int j = 0;j&lt;v;j++){
                    grid[i][j] = sc.nextInt();
                }
            }
            floydWarshall(grid, v);
            sc.close();
        }
        
    }</code></pre><p id="15758fd8-d211-80c6-8776-caec6b10d0e2" class="">
    </p></div></article><span class="sans" style="font-size:14px;padding-top:2em"></span></body></html>